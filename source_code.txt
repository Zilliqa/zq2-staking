Project Path: src

Source Tree:

```txt
src
├── components
│   ├── customWalletConnect.tsx
│   ├── dummyWalletSelector.tsx
│   ├── fastFadeScroll.tsx
│   ├── filterBtn.tsx
│   ├── lastTransaction.tsx
│   ├── loginView.tsx
│   ├── mobilePopup.tsx
│   ├── sortBtn.tsx
│   ├── stakingCalculator.tsx
│   ├── stakingPoolCard.tsx
│   ├── stakingPoolDetailsView.tsx
│   ├── stakingPoolsList.tsx
│   ├── unstakingCalculator.tsx
│   ├── withdrawUnstakedZilPanel.tsx
│   ├── withdrawZilView.tsx
│   └── zilGiveaway.tsx
├── contexts
│   ├── appConfigStorage.tsx
│   ├── context.tsx
│   ├── dummyConnector.tsx
│   ├── stakingOperations.tsx
│   ├── stakingPoolsStorage.tsx
│   └── walletConnector.tsx
├── misc
│   ├── chainConfig.ts
│   ├── formatting.ts
│   ├── stakingAbis.ts
│   ├── stakingPoolsConfig.ts
│   └── walletsConfig.ts
├── pages
│   ├── _app.tsx
│   ├── _document.tsx
│   ├── api
│   │   ├── config.ts
│   │   └── health.ts
│   └── index.tsx
└── script
    └── fetchPoolStaticData.ts

```

`src/components/customWalletConnect.tsx`:

```tsx
import { AppConfigStorage } from "@/contexts/appConfigStorage"
import { WalletConnector } from "@/contexts/walletConnector"
import { MOCK_CHAIN } from "@/misc/chainConfig"
import { formatAddress, formatUnitsToHumanReadable } from "@/misc/formatting"
import { WalletOutlined } from "@ant-design/icons"
import { ConnectButton } from "@rainbow-me/rainbowkit"
import { Button } from "antd"

/**
 * notConnectedClassName will be used for other cases if if connectedClassName or wrongNetworkClassName is not provided
 */
interface CustomWalletConnectProps {
  children: React.ReactNode
  notConnectedClassName: string
}

const CustomWalletConnect: React.FC<CustomWalletConnectProps> = ({
  children,
  notConnectedClassName,
}) => {
  const { appConfig } = AppConfigStorage.useContainer()

  const {
    isDummyWalletConnecting,
    connectDummyWallet,
    disconnectDummyWallet,
    isDummyWalletConnected,
    walletAddress,
    zilAvailable,
  } = WalletConnector.useContainer()

  if (appConfig.chainId === MOCK_CHAIN.id) {
    if (!isDummyWalletConnected) {
      return (
        <Button
          type="primary"
          onClick={connectDummyWallet}
          loading={isDummyWalletConnecting}
          className={notConnectedClassName}
        >
          {children}
        </Button>
      )
    } else {
      return (
        <Button
          type="primary"
          className="group relative btn-primary-teal max-lg:px-5 max-lg:w-fit lg:min-w-[160px]"
          onClick={disconnectDummyWallet}
        >
          <div className=" group-hover:hidden transition-opacity flex items-center justify-center">
            <WalletOutlined className="mr-2 !text-black-100" />
            {formatAddress(walletAddress || "")} |{" "}
            {formatUnitsToHumanReadable(zilAvailable || 0n, 18)} ZIL
          </div>
          <span className=" !hidden group-hover:!block transition-opacity  items-center justify-center">
            Disconnect
          </span>
        </Button>
      )
    }
  } else {
    return (
      <ConnectButton.Custom>
        {({ account, chain, mounted, openConnectModal }) => {
          if (!mounted) {
            return (
              <Button className={notConnectedClassName}>refreshing...</Button>
            )
          }

          // Not connected
          if (!account || !chain) {
            return (
              <Button
                onClick={openConnectModal}
                className={notConnectedClassName}
              >
                {children}
              </Button>
            )
          }

          // all other cases
          return (
            <div className="flex w-fit justify-end items-center ">
              <ConnectButton />
            </div>
          )
        }}
      </ConnectButton.Custom>
    )
  }
}

export default CustomWalletConnect

```

`src/components/dummyWalletSelector.tsx`:

```tsx
import { WalletConnector } from "@/contexts/walletConnector"
import { dummyWallets } from "@/misc/walletsConfig"
import { Modal, Radio, Space } from "antd"
import { useState } from "react"

const DummyWalletSelector: React.FC = () => {
  const {
    isDummyWalletSelectorOpen,
    selectDummyWallet,
    disconnectDummyWallet,
  } = WalletConnector.useContainer()

  const [walletIndex, setValue] = useState(0)

  const selectedWalletChanged = (e: any) => {
    setValue(e.target.value)
  }

  return (
    <>
      <Modal
        title="Available mock wallets"
        open={isDummyWalletSelectorOpen}
        okText="Connect"
        onOk={() => selectDummyWallet(dummyWallets[walletIndex])}
        onCancel={disconnectDummyWallet}
        okButtonProps={{ className: "btn-primary-cyan" }}
      >
        <Radio.Group onChange={selectedWalletChanged} value={walletIndex}>
          <Space direction="vertical">
            {dummyWallets.map((wallet, index) => (
              <Radio key={index} value={index}>
                {wallet.name}
              </Radio>
            ))}
          </Space>
        </Radio.Group>
      </Modal>
    </>
  )
}

export default DummyWalletSelector

```

`src/components/fastFadeScroll.tsx`:

```tsx
import { StakingPoolType } from "@/misc/stakingPoolsConfig"
import { useState, useEffect, ReactNode } from "react"

interface FastFadeScrollProps {
  children: ReactNode
  fadeDuration?: number
  className?: string
  isPoolLiquid?: StakingPoolType
}

const FastFadeScroll = ({
  children,
  fadeDuration = 1000,
  className = "",
  isPoolLiquid,
}: FastFadeScrollProps) => {
  const [isScrolling, setIsScrolling] = useState(false)
  let scrollTimeout: any

  const handleScroll = () => {
    setIsScrolling(true)
    clearTimeout(scrollTimeout)

    scrollTimeout = setTimeout(() => {
      setIsScrolling(false)
    }, fadeDuration)
  }

  useEffect(() => {
    return () => clearTimeout(scrollTimeout)
  }, [])

  const isPoolLiquidBool = () => isPoolLiquid === StakingPoolType.LIQUID

  return (
    <div
      onScroll={handleScroll}
      className={`${className} ${isScrolling ? "scrollbar-visible" : "scrollbar-hidden"}
        ${isPoolLiquidBool() ? "scrollbar-aqua" : "scrollbar-purple"}`}
    >
      {children}
    </div>
  )
}

export default FastFadeScroll

```

`src/components/filterBtn.tsx`:

```tsx
import React, { useState } from "react"

interface FilterBtnProps {
  variable: String
  onClick: () => void
  isActive: boolean
  activeGradient: string
}

const FilterBtn: React.FC<FilterBtnProps> = ({
  variable,
  onClick,
  isActive,
  activeGradient,
}) => {
  return (
    <div
      className={`btn-filter group ${isActive ? activeGradient : "not-active"}`}
      onClick={onClick}
    >
      <div className="base px-2 duration-300 group-hover:text-white ease-in-out">
        {variable}
      </div>
    </div>
  )
}

export default FilterBtn

```

`src/components/lastTransaction.tsx`:

```tsx
import { AppConfigStorage } from "@/contexts/appConfigStorage"
import { formatAddress, getTxExplorerUrl } from "@/misc/formatting"
import Link from "next/link"
import React from "react"

export interface LastTransactionProps {
  txHash?: string
}

const LastTransaction: React.FC<LastTransactionProps> = ({ txHash }) => {
  const { appConfig } = AppConfigStorage.useContainer()

  return txHash !== undefined ? (
    <div className="text-center mb-3 info-label">
      <Link
        rel="noopener noreferrer"
        target="_blank"
        href={getTxExplorerUrl(txHash, appConfig.chainId)}
        passHref={true}
        className="text-gray2"
      >
        Last transaction:{" "}
        <span className="text-white underline hover:text-tealPrimary active:text-teal1">
          {" "}
          {formatAddress(txHash)}
        </span>
      </Link>
    </div>
  ) : (
    <></>
  )
}

export default LastTransaction

```

`src/components/loginView.tsx`:

```tsx
import Image from "next/image"
import ArrowRightWhite from "../assets/svgs/arrow-right-white.svg"
import CustomWalletConnect from "@/components/customWalletConnect"

const LoginView: React.FC = () => {
  return (
    <div className="relative">
      <div className="text-center p-4">
        <h1 className="bold33 lg:mt-20 4k:mt-56">
          Stake ZIL. <br /> Earn Rewards.
          <br /> Secure the Network.
        </h1>
        <p className="mt-6 body2-v2">
          Give it a try, and give us your feedback !
        </p>
      </div>

      <div className="flex flex-col items-center mt-12 ">
        <CustomWalletConnect notConnectedClassName="btn-primary-teal !w-fit px-14 group flex items-center">
          <div className="flex">
            Connect wallet
            <Image
              className="ml-3 h-6 w-6 transform transition-transform ease-out duration-500 group-hover:translate-x-2"
              src={ArrowRightWhite}
              alt="arrow icon"
              width={24}
              height={24}
            />
          </div>
        </CustomWalletConnect>
      </div>
    </div>
  )
}

export default LoginView

```

`src/components/mobilePopup.tsx`:

```tsx
import Image from "next/image"
import React, { useState, useEffect } from "react"
import close from "../assets/svgs/close-icon-small.svg"
import { StakingPoolsStorage } from "@/contexts/stakingPoolsStorage"
import { useRouter } from "next/router"
import CustomWalletConnect from "@/components/customWalletConnect"
import ArrowRightWhite from "../assets/svgs/arrow-icon.svg"
interface MobilePopupProps {
  isOpen: boolean
  onClose: () => void
  isWalletConnected: boolean // Add this prop
}
const MobilePopup = ({
  isOpen,
  onClose,
  isWalletConnected,
}: MobilePopupProps) => {
  const { stakingPoolForView } = StakingPoolsStorage.useContainer()
  const router = useRouter()

  // Add this useEffect to watch wallet connection state
  useEffect(() => {
    if (isWalletConnected) {
      onClose()
    }
  }, [isWalletConnected, onClose])

  if (!isOpen) return null

  return (
    <div
      className={`fixed inset-0 mx-4 z-50 md:hidden bg-gray  ${isOpen ? "visible" : "invisible"}`}
      onClick={onClose}
    >
      <div
        className={`absolute bottom-0 left-0 right-0 rounded-t-15 border-t border-r border-l border-gray2 
                 bg-aqua-grey-gradient backdrop-blur-17 p-5 transform transition-transform duration-300 ease-out
                 ${isOpen ? "translate-y-0" : "translate-y-full"}`}
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-end ">
          <button onClick={onClose} aria-label="Close">
            <Image alt="Close Icon" src={close} width={20} height={20} />
          </button>
        </div>
        <div className="flex flex-col items-center justify-between text-center pt-4 pb-10 ">
          <h2 className="text-white1 body1">Start earning ZIL</h2>
          <p className="text-gray2 medium15 mt-3 ">
            Stake ZIL. <br /> Earn Rewards.
            <br /> Secure the Network.
          </p>
          <div className="flex items-center space-x-4 mt-6">
            <CustomWalletConnect notConnectedClassName="capitalize text-base  font-bold btn-primary-teal !w-fit  group flex items-center justify-center">
              Connect wallet
              <Image
                className="  h-4 w-4 transform transition-transform ease-out duration-500 group-hover:translate-x-2"
                src={ArrowRightWhite}
                alt="arrow icon"
                width={13}
                height={13}
              />
            </CustomWalletConnect>
          </div>
        </div>
      </div>
    </div>
  )
}

export default MobilePopup

```

`src/components/sortBtn.tsx`:

```tsx
import React, { useState } from "react"
import { Tooltip } from "antd"
interface SortBtnProps {
  liquidType: Boolean
  variable: String
  isClicked: Boolean
  onClick: () => void
  tooltip: String
}

const SortBtn: React.FC<SortBtnProps> = ({
  liquidType,
  variable,
  isClicked,
  onClick,
  tooltip,
}) => {
  return (
    <Tooltip
      placement="top"
      arrow={true}
      overlayClassName="custom-tooltip"
      title={tooltip}
    >
      <div
        className={`btn-filter group  ${isClicked ? (liquidType ? "bg-tealPrimary" : "bg-purplePrimary") : "not-active"}`}
        onClick={onClick}
      >
        <svg
          width="14"
          height="12"
          viewBox="0 0 14 12"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
          className={`duration-300 stroke-gray3 group-hover:stroke-white ease-in-out ${
            isClicked ? "scale-y-[-1]" : ""
          }`}
        >
          <path
            d="M9.625 10.9487L9.625 0.999985"
            stroke="white"
            strokeMiterlimit="10"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
          <path
            d="M12.8945 7.68873L9.62453 10.9487L6.35453 7.68873"
            stroke="white"
            strokeMiterlimit="10"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
          <path
            d="M1 1L7.5 0.999999"
            stroke="white"
            strokeMiterlimit="10"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
          <path
            d="M3.5 3.375L7.5 3.375"
            stroke="white"
            strokeMiterlimit="10"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        </svg>

        <div className="base ml-1 duration-300 group-hover:text-white ease-in-out">
          {variable}
        </div>
      </div>
    </Tooltip>
  )
}

export default SortBtn

```

`src/components/stakingCalculator.tsx`:

```tsx
import { StakingPoolsStorage } from "@/contexts/stakingPoolsStorage"
import { useEffect, useRef, useState } from "react"
import { Button, Input, InputRef, Tooltip } from "antd"
import { WalletConnector } from "@/contexts/walletConnector"
import {
  formatPercentage,
  convertZilValueToToken,
  getHumanFormDuration,
  convertTokenToZil,
  formatUnitsWithMaxPrecision,
} from "@/misc/formatting"
import { formatUnits, parseEther } from "viem"
import { StakingOperations } from "@/contexts/stakingOperations"
import { StakingPoolType } from "@/misc/stakingPoolsConfig"
import CustomWalletConnect from "@/components/customWalletConnect"
import { DateTime } from "luxon"
import LastTransaction from "@/components/lastTransaction"

const StakingCalculator: React.FC = () => {
  const inputRef = useRef<InputRef | null>(null)

  const { isWalletConnected } = WalletConnector.useContainer()

  const { zilAvailable } = WalletConnector.useContainer()
  const {
    stake,
    preparingStakingTx,
    isStakingInProgress,
    stakingCallTxHash,
    stakeContractCallError,
    stakingCallZilFees,
  } = StakingOperations.useContainer()

  const { stakingPoolForView } = StakingPoolsStorage.useContainer()

  const [zilToStake, setZilToStake] = useState<string>("0")

  const [isMinValue, setIsMinValue] = useState(false)
  const [isMaxValue, setIsMaxValue] = useState(false)

  const minValue = formatUnits(
    stakingPoolForView?.stakingPool.definition.minimumStake || 0n,
    18
  )
  const allZil = formatUnits(zilAvailable || 0n, 18)
  const roundedToNiceNumber = allZil.split(".")[0]
  const maxValue = parseFloat(roundedToNiceNumber) - stakingCallZilFees

  const onMinClick = () => {
    setIsMaxValue(false)
    setIsMinValue(true)
    setZilToStake(`${minValue}`)
  }

  const onMaxClick = () => {
    setIsMaxValue(true)
    setIsMinValue(false)
    setZilToStake(`${maxValue}`)
  }

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { value: inputValue } = e.target
    const reg = /^-?\d*(\.\d*)?$/
    if (reg.test(inputValue) || inputValue === "" || inputValue === "-") {
      setZilToStake(inputValue)

      setIsMinValue(inputValue === `${minValue}`)
      setIsMaxValue(inputValue === `${maxValue}`)
    }
  }
  const [isFocused, setIsFocused] = useState(true)

  const handleFocus = () => {
    if (parseEther(minValue) < (zilAvailable || 0n)) setIsFocused(true)
    setIsFocused(true)
  }

  const handleBlur = () => {
    let valueTemp = zilToStake
    if (
      zilToStake.charAt(zilToStake.length - 1) === "." ||
      zilToStake === "-"
    ) {
      valueTemp = zilToStake.slice(0, -1)
    }
    setZilToStake(valueTemp.replace(/0*(\d+)/, "$1"))
    setIsFocused(false)
  }

  const zilToStakeNumber = parseFloat(zilToStake)
  const zilInWei = parseEther(zilToStake)

  const { canStake, whyCantStake } = (() => {
    if (!stakingPoolForView?.stakingPool.data) {
      return {
        canStake: false,
        whyCantStake: "Loading staking pool data",
      }
    } else if (!isWalletConnected) {
      return {
        canStake: false,
        whyCantStake: "Please connect your wallet first.",
      }
    } else if (zilToStakeNumber <= 0 || isNaN(zilToStakeNumber)) {
      return {
        canStake: false,
        whyCantStake: "Please enter a valid amount",
      }
    } else if (zilInWei > (zilAvailable || 0n)) {
      return {
        canStake: false,
        whyCantStake: "Insufficient ZIL balance",
      }
    } else if (
      zilInWei + parseEther(`${stakingCallZilFees}`) >
      (zilAvailable || 0n)
    ) {
      return {
        canStake: false,
        whyCantStake: `Remaining ZIL balance insufficient for ${stakingCallZilFees} ZIL transaction fee`,
      }
    } else if (
      zilInWei < stakingPoolForView.stakingPool.definition.minimumStake
    ) {
      return {
        canStake: false,
        whyCantStake: `Amount ${zilToStakeNumber} ZIL is below minimum stake ${formatUnits(stakingPoolForView.stakingPool.definition.minimumStake, 18)} ZIL`,
      }
    } else {
      return {
        canStake: true,
        whyCantStake: "",
      }
    }
  })()

  const isPoolLiquid = () =>
    stakingPoolForView?.stakingPool.definition.poolType ===
    StakingPoolType.LIQUID

  const unboudingPeriod = getHumanFormDuration(
    DateTime.now().plus({
      minutes:
        stakingPoolForView?.stakingPool.definition.withdrawPeriodInMinutes || 0,
    })
  )

  useEffect(() => {
    if (isFocused && inputRef.current) {
      inputRef.current.focus()
    }
  }, [isFocused])

  const [isMinHovered, setIsMinHovered] = useState(false)
  const [isMaxHovered, setIsMaxHovered] = useState(false)

  return (
    stakingPoolForView && (
      <>
        <div className="">
          <Tooltip
            placement="bottomLeft"
            arrow={true}
            overlayClassName="custom-tooltip"
            className=""
            title={
              canStake
                ? `Stake ZIL with ${stakingPoolForView!.stakingPool.data ? formatPercentage(stakingPoolForView?.stakingPool.data.apr) : 0} APR`
                : whyCantStake
            }
          >
            <div
              className={`transition-all duration-300 border-transparent bg-gray-gradient
              ${
                isWalletConnected &&
                ` ${isFocused && "ant-input-affix-wrapper-focused !border-transparent !bg-focus-gradient "}
                  ${isMaxValue && "bg-teal-gradient !border-teal"}
                  ${isMaxHovered && "!bg-teal-gradient"}
                  ${isMinValue && "bg-purple-gradient"}
                  ${isMinHovered && "!bg-purple-gradient"}
                  ${!canStake && zilToStake != "0" && zilToStake != "" && "!bg-red-gradient"}`
              } flex justify-between lg:gap-10 4k:gap-14 mb-2.5 lg:mb-4 4k:mb-6 p-3 lg:p-5 xl:p-7 4k:p-10 rounded-xl items-center`}
            >
              <div className="h-fit self-center">
                <div className=" flex items-center gap-2">
                  <div
                    className={`${
                      !isWalletConnected ? "text-gray3" : "text-white1"
                    } bold33`}
                  >
                    ZIL
                  </div>
                  <Input
                    ref={inputRef}
                    placeholder="0"
                    className={` ${
                      zilToStake === "0" || zilToStake === ""
                        ? "text-gray2"
                        : "text-white1"
                    } 
                        
                    ${
                      !isWalletConnected
                        ? "placeholder-gray3"
                        : "placeholder-gray2"
                    }
                         flex items-baseline !bg-transparent !border-transparent !shadow-none bold33 px-0`}
                    value={zilToStake !== "0" ? zilToStake || "" : ""}
                    onChange={handleChange}
                    onFocus={handleFocus}
                    onBlur={handleBlur}
                    status={!canStake ? "warning" : undefined}
                    disabled={!isWalletConnected || isStakingInProgress}
                  />
                </div>

                <span className="flex items-center whitespace-nowrap ">
                  {stakingPoolForView!.stakingPool.data ? (
                    <>
                      {isPoolLiquid() && (
                        <span
                          className={` mr-3 ${
                            !isWalletConnected && "text-gray3"
                          } medium17`}
                        >
                          ~
                          {!isNaN(zilToStakeNumber) &&
                          !isNaN(
                            stakingPoolForView.stakingPool.data.zilToTokenRate
                          )
                            ? convertZilValueToToken(
                                zilToStakeNumber,
                                stakingPoolForView.stakingPool.data
                                  .zilToTokenRate
                              )
                            : ""}{" "}
                          {
                            stakingPoolForView.stakingPool.definition
                              .tokenSymbol
                          }{" "}
                        </span>
                      )}
                      <span
                        className={`
                         ${
                           !isWalletConnected
                             ? "text-gray3"
                             : stakingPoolForView?.stakingPool.definition
                                   .poolType === StakingPoolType.LIQUID
                               ? "text-tealPrimary"
                               : "text-purple2"
                         } medium17 mr-1`}
                      >
                        ~
                        {formatPercentage(
                          stakingPoolForView!.stakingPool.data.apr
                        )}
                      </span>
                    </>
                  ) : (
                    <div className="loading-blur mr-1  ">
                      {" "}
                      ~ formatPercentage{" "}
                    </div>
                  )}
                  <span
                    className={`
                        ${
                          !isWalletConnected
                            ? "text-gray3"
                            : stakingPoolForView?.stakingPool.definition
                                  .poolType === StakingPoolType.LIQUID
                              ? "text-tealPrimary"
                              : "text-purple2"
                        } medium17`}
                  >
                    APR
                  </span>
                </span>
              </div>

              <div className="flex flex-col gap-3 ">
                <Button
                  className={`btn-secondary-teal ${isMaxValue && "!border-tealPrimary"}`}
                  onClick={onMaxClick}
                  onMouseEnter={() => setIsMaxHovered(true)}
                  onMouseLeave={() => setIsMaxHovered(false)}
                  disabled={
                    !isWalletConnected ||
                    parseEther(minValue) > (zilAvailable || 0n) ||
                    isStakingInProgress
                  }
                >
                  MAX
                </Button>
                <Button
                  className={`btn-secondary-purple ${isMinValue && "!border-purplePrimary"}`}
                  onClick={onMinClick}
                  onMouseEnter={() => setIsMinHovered(true)}
                  onMouseLeave={() => setIsMinHovered(false)}
                  disabled={!isWalletConnected || isStakingInProgress}
                >
                  MIN
                </Button>
              </div>
            </div>
          </Tooltip>
          <div className="flex flex-col">
            <div className="flex mt-2 mb-3">
              {isWalletConnected ? (
                <>
                  {canStake || isStakingInProgress ? (
                    <Button
                      type="default"
                      size="large"
                      className={`${
                        stakingPoolForView?.stakingPool.definition.poolType ===
                        StakingPoolType.LIQUID
                          ? "btn-primary-teal-lg lg:btn-primary-teal "
                          : "btn-primary-purple-lg lg:btn-primary-purple "
                      } mx-auto lg:w-1/2 w-2/3 `}
                      onClick={() =>
                        stake(
                          stakingPoolForView.stakingPool.definition.address,
                          zilInWei
                        )
                      }
                      loading={isStakingInProgress}
                    >
                      {preparingStakingTx
                        ? "Confirm in wallet"
                        : isStakingInProgress
                          ? "Processing"
                          : "Stake"}
                    </Button>
                  ) : (
                    <Tooltip
                      placement="top"
                      arrow={true}
                      overlayClassName="custom-tooltip"
                      title={whyCantStake}
                    >
                      <Button
                        type="default"
                        size="large"
                        className="btn-primary-teal-lg lg:btn-primary-teal  mx-auto lg:w-1/2 w-2/3"
                        disabled={true}
                      >
                        Stake
                      </Button>
                    </Tooltip>
                  )}
                </>
              ) : (
                <CustomWalletConnect notConnectedClassName="btn-primary-teal sm:px-10 sm:max-w-fit mx-auto lg:w-1/2 w-2/3">
                  Connect wallet
                </CustomWalletConnect>
              )}
            </div>

            <LastTransaction txHash={stakingCallTxHash} />

            <div className="flex justify-between pt-2.5 lg:pt-5 4k:pt-7 mt-2.5 lg:mt-4 4k:mt-6 border-t border-black1 lg:pb-10">
              <div className="flex flex-col lg:gap-2.5 gap-1 4k:gap-4 regular-base">
                <div className=" flex ">
                  Commission Fee:{" "}
                  {stakingPoolForView!.stakingPool.data ? (
                    <>
                      {formatPercentage(
                        stakingPoolForView!.stakingPool.data.commission
                      )}
                    </>
                  ) : (
                    <div className="loading-blur ml-1  "> 10% </div>
                  )}
                </div>
                <div>Max transaction cost: ~{stakingCallZilFees} ZIL</div>
                <div>
                  <Tooltip
                    placement="top"
                    arrow={true}
                    overlayClassName="custom-tooltip"
                    className=""
                    title="How long before you can claim your ZIL after unstaking."
                  >
                    Unbonding Period: {unboudingPeriod}{" "}
                  </Tooltip>{" "}
                </div>
              </div>
              <div className="flex flex-col lg:gray-base gray-base2 xl:gap-2.5 4k:gap-5 xl:items-end justify-start">
                {isPoolLiquid() && (
                  <div className="flex  max-lg:gap-2 max-xl:justify-between max-lg:items-start flex-row xl:gap-5 4k:gap-6">
                    <div className=" ">Rate</div>
                    {stakingPoolForView!.stakingPool.data ? (
                      <div className="text-gray1">
                        <>
                          1{" "}
                          {
                            stakingPoolForView.stakingPool.definition
                              .tokenSymbol
                          }{" "}
                          =~
                          {formatUnitsWithMaxPrecision(
                            convertTokenToZil(
                              parseEther("1"),
                              stakingPoolForView.stakingPool.data.zilToTokenRate
                            ),
                            18,
                            5
                          )}
                        </>{" "}
                        ZIL
                      </div>
                    ) : (
                      <div className="loading-blur ml-1 "> 1 ZIL = ~00%</div>
                    )}
                  </div>
                )}
                <div
                  className={`${
                    stakingPoolForView?.stakingPool.definition.poolType ===
                    StakingPoolType.LIQUID
                      ? "text-tealPrimary"
                      : "text-purple2"
                  }  flex flex-row xl:gap-5 4k:gap-6 `}
                >
                  <Tooltip
                    placement="top"
                    arrow={true}
                    overlayClassName="custom-tooltip"
                    className=" mr-1"
                    title="Annual Percentage Rate"
                  >
                    <span
                      className={`${
                        stakingPoolForView?.stakingPool.definition.poolType ===
                        StakingPoolType.LIQUID
                          ? "text-tealPrimary"
                          : "text-purple2"
                      } lg:gray-base gray-base2 `}
                    >
                      APR{" "}
                    </span>
                  </Tooltip>
                  {stakingPoolForView!.stakingPool.data ? (
                    <>
                      ~
                      {formatPercentage(
                        stakingPoolForView!.stakingPool.data.apr
                      )}
                    </>
                  ) : (
                    <div className="loading-blur ml-1 "> ~00%</div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>

        {stakeContractCallError && (
          <div className="text-red1 text-center">
            {stakeContractCallError.message}
          </div>
        )}
      </>
    )
  )
}

export default StakingCalculator

```

`src/components/stakingPoolCard.tsx`:

```tsx
import {
  convertTokenToZil,
  formatPercentage,
  formatUnitsToHumanReadable,
} from "@/misc/formatting"
import { StakingPool, StakingPoolType } from "@/misc/stakingPoolsConfig"
import { UserStakingPoolData } from "@/misc/walletsConfig"
import { Tooltip } from "antd"
import Image from "next/image"

interface StakingPoolCardProps {
  stakingPoolData: StakingPool
  userStakingPoolData?: UserStakingPoolData
  isStakingPoolSelected?: boolean
  onClick: () => void
}

const StakingPoolCard: React.FC<StakingPoolCardProps> = ({
  stakingPoolData,
  userStakingPoolData,
  isStakingPoolSelected,
  onClick,
}) => {
  return (
    <div
      className={`
        ${
          isStakingPoolSelected
            ? "gradient-bottom-border "
            : "border-b-[1.5px] border-black1 rounded-10 hover:bg-gray-grad hover:border-gray3  "
        } ${isStakingPoolSelected && "bg-black"} hover:cursor-pointer`}
      onClick={onClick}
    >
      <div
        className={`${
          isStakingPoolSelected ? "content" : "content-hover p-2.5 lg:p-5"
        } flex justify-between items-center`}
      >
        <Image
          className="mr-5 4k:mr-6 rounded-[9.5px] h-[61px] w-[61px] hidden md:block"
          src={stakingPoolData.definition.iconUrl}
          alt={`${stakingPoolData.definition.name} icon`}
          width={61}
          height={61}
        />
        <div className="flex flex-col  w-full">
          <div className="flex justify-between items-center">
            <div className="flex gap-2 4k:gap-3 items-center mb-3">
              <Image
                className=" rounded-10 h5 w-5 xs:h-[30px] xs:w-[30px] md:hidden block"
                src={stakingPoolData.definition.iconUrl}
                alt={`${stakingPoolData.definition.name} icon`}
                width={40}
                height={40}
              />
              <h3 className="bold22">{stakingPoolData.definition.name}</h3>
              <div className="base-medium mt-1">
                {stakingPoolData.definition.tokenSymbol}
              </div>
            </div>
            <div>
              {userStakingPoolData &&
                userStakingPoolData.stakingTokenAmount && (
                  <Tooltip
                    placement="top"
                    arrow={true}
                    overlayClassName="custom-tooltip"
                    className="mr-1 4k:mr-1.5"
                    title={
                      stakingPoolData.data ? (
                        stakingPoolData.definition.poolType ===
                        StakingPoolType.LIQUID ? (
                          <>
                            <div>Your staked value</div>
                            <div className="mt-1">
                              ( ~
                              {formatUnitsToHumanReadable(
                                convertTokenToZil(
                                  userStakingPoolData.stakingTokenAmount,
                                  stakingPoolData.data.zilToTokenRate
                                ),
                                18
                              )}{" "}
                              ZIL )
                            </div>
                          </>
                        ) : (
                          <>
                            <div>Your staked value</div>
                          </>
                        )
                      ) : (
                        "Loading value..."
                      )
                    }
                  >
                    <span
                      className={`${stakingPoolData.definition.poolType === StakingPoolType.LIQUID ? "text-tealPrimary" : "text-purple2"} regular15 `}
                    >
                      {userStakingPoolData &&
                        `${formatUnitsToHumanReadable(
                          userStakingPoolData.stakingTokenAmount,
                          stakingPoolData.definition.tokenDecimals
                        )} ${stakingPoolData.definition.tokenSymbol}`}
                    </span>
                  </Tooltip>
                )}
            </div>
          </div>

          <div className="flex justify-between items-center">
            <div className="flex lg:justify-between lg:w-full items-center">
              <div className="flex max-lg:order-2 items-center">
                {stakingPoolData.data ? (
                  <div
                    className={`lg:medium12 regular12 4k:pr-1.5 pr-1 xs:pr-3 ${
                      stakingPoolData.data.votingPower * 100 >= 50
                        ? "text-red1"
                        : stakingPoolData.data.votingPower * 100 >= 30
                          ? "text-orange1"
                          : ""
                    }`}
                  >
                    VP {(stakingPoolData.data.votingPower * 100).toPrecision(3)}
                    %
                  </div>
                ) : (
                  <div className="4k:pr-1.5 pr-1 xs:pr-3 loading-blur">
                    <span className="lg:medium12 regular12">VP</span>
                    <span className="mr-1 4k:mr-1.5 ">0%</span>
                  </div>
                )}
                <div className="flex medium12 4k:pl-1.5 pl-1 xs:pl-3 border-l-[1px] border-gray3">
                  {stakingPoolData.data ? (
                    <>
                      {" "}
                      Commission{" "}
                      {Math.floor(stakingPoolData.data.commission * 100)}%
                    </>
                  ) : (
                    <span className=" whitespace-nowrap mr-1 4k:mr-1.5 loading-blur">
                      Commission 0%
                    </span>
                  )}
                </div>
              </div>
            </div>

            <div className="flex bold15 max-md:order-1 4k:ml-2.5 ml-2 xs:ml-6">
              {stakingPoolData.data ? (
                <>
                  <Tooltip
                    placement="top"
                    arrow={true}
                    overlayClassName="custom-tooltip"
                    className="mr-1 4k:mr-1.5"
                    title="Annual Percentage Rate"
                  >
                    <span>APR </span>
                  </Tooltip>

                  {formatPercentage(stakingPoolData.data.apr)}
                </>
              ) : (
                <div className=" whitespace-nowrap mr-1 4k:mr-1.5 loading-blur">
                  APR 000%
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default StakingPoolCard

```

`src/components/stakingPoolDetailsView.tsx`:

```tsx
import StakingCalculator from "@/components/stakingCalculator"
import UnstakingCalculator from "@/components/unstakingCalculator"
import WithdrawZilPanel from "@/components/withdrawUnstakedZilPanel"
import { WalletConnector } from "@/contexts/walletConnector"
import {
  convertTokenToZil,
  formatPercentage,
  formatUnitsToHumanReadable,
  formatUnitsWithMaxPrecision,
} from "@/misc/formatting"
import { StakingPool, StakingPoolType } from "@/misc/stakingPoolsConfig"
import {
  UserNonLiquidStakingPoolRewardData,
  UserStakingPoolData,
  UserUnstakingPoolData,
} from "@/misc/walletsConfig"
import { DateTime } from "luxon"
import { useEffect, useState } from "react"
import { useWatchAsset } from "wagmi"
import PlusIcon from "../assets/svgs/plus-icon.svg"
import Image from "next/image"
import CloseIcon from "../assets/svgs/close-icon.svg"
import FastFadeScroll from "@/components/fastFadeScroll"
import { parseEther } from "viem"
import arrow from "../assets/svgs/arrow.svg"
import { StakingPoolsStorage } from "@/contexts/stakingPoolsStorage"
import { Tooltip } from "antd"
import { AppConfigStorage } from "@/contexts/appConfigStorage"
import { CHAIN_ZQ2_PROTOMAINNET } from "@/misc/chainConfig"

interface StakingPoolDetailsViewProps {
  stakingPoolData: StakingPool
  userStakingPoolData?: UserStakingPoolData
  userUnstakingPoolData?: Array<UserUnstakingPoolData>
  viewClaim?: boolean
  reward?: UserNonLiquidStakingPoolRewardData
}

const StakingPoolDetailsView: React.FC<StakingPoolDetailsViewProps> = ({
  stakingPoolData,
  userStakingPoolData,
  userUnstakingPoolData,
  viewClaim,
  reward,
}) => {
  const { selectStakingPoolForView } = StakingPoolsStorage.useContainer()

  const { zilAvailable } = WalletConnector.useContainer()
  const { appConfig } = AppConfigStorage.useContainer()

  const [selectedPane, setSelectedPane] = useState<string>("Stake")

  useEffect(() => {
    if (viewClaim === true) setSelectedPane("Claim")
    else setSelectedPane("Stake")
  }, [viewClaim])

  const isPoolLiquid = () =>
    stakingPoolData.definition.poolType === StakingPoolType.LIQUID
  const colorInfoEntry = (
    title: string,
    value: string | null,
    tooltip: string | JSX.Element | null
  ) => (
    <Tooltip
      placement="topLeft"
      arrow={true}
      overlayClassName="custom-tooltip"
      className=""
      title={tooltip}
    >
      <div
        className={`${isPoolLiquid() ? "lg:w-1/4 w-1/2 lg:text-left text-center" : " xl:text-left text-center w-1/3"}`}
      >
        <div
          className={`semi14 ${isPoolLiquid() ? "text-tealPrimary" : "text-purple3"}`}
        >
          {value}
        </div>

        <div className="text-gray2 info-label">{title}</div>
      </div>
    </Tooltip>
  )
  const asideColorInfoEntry = (
    title: string,
    value: string | null,
    tooltip: string | JSX.Element | null
  ) => (
    <Tooltip
      key={title}
      placement="top"
      arrow={true}
      overlayClassName="custom-tooltip"
      className=""
      title={tooltip}
    >
      <div
        className={`${isPoolLiquid() ? "lg:text-left text-center" : "xl:text-left text-center"} w-2/3 `}
      >
        <div
          className={`semi14  ${isPoolLiquid() ? "text-tealPrimary" : "text-purple3"}`}
        >
          {value}
        </div>

        <div className="text-gray2 xl:whitespace-nowrap info-label">
          {title}
        </div>
      </div>
    </Tooltip>
  )
  const greyInfoEntry = (
    title: string,
    value: string | JSX.Element | null,
    tooltip: string | JSX.Element | null
  ) => (
    <Tooltip
      key={title}
      placement="topLeft"
      arrow={true}
      overlayClassName="custom-tooltip"
      className=""
      title={tooltip}
    >
      <div className={`  ${isPoolLiquid() ? "lg:w-1/4 w-1/2" : "w-1/3"} `}>
        {value ? (
          <div className="semi14 xl:whitespace-nowrap">{value}</div>
        ) : (
          <div className="loading-blur">0000</div>
        )}
        <div className="text-gray2 info-label xl:whitespace-nowrap">
          {title}
        </div>
      </div>
    </Tooltip>
  )
  const pendingUnstakesValue = userUnstakingPoolData
    ?.filter((item) => item.availableAt > DateTime.now())
    .reduce((acc, item) => acc + item.zilAmount, 0n)

  const availableToClaim = userUnstakingPoolData
    ?.filter((item) => item.availableAt <= DateTime.now())
    .reduce((acc, item) => acc + item.zilAmount, 0n)

  const doesUserHoldAnyFundsInThisPool = !!(
    userStakingPoolData?.stakingTokenAmount ||
    pendingUnstakesValue ||
    availableToClaim
  )

  const humanReadableStakingToken = (value: bigint) =>
    formatUnitsToHumanReadable(value, stakingPoolData.definition.tokenDecimals)

  const { watchAsset } = useWatchAsset()

  const handleClickAddToken = () => {
    // this is a workaround for the protomainnet stZIL delegator, can be removed once we switch to actual mainnet
    const symbol = (() => {
      if (
        appConfig.chainId === CHAIN_ZQ2_PROTOMAINNET.id &&
        stakingPoolData.definition.tokenSymbol === "stZIL"
      ) {
        return "YourTokenSymbol"
      } else {
        return stakingPoolData.definition.tokenSymbol
      }
    })()

    watchAsset(
      {
        type: "ERC20",
        options: {
          address: stakingPoolData.definition.tokenAddress,
          symbol: symbol,
          decimals: stakingPoolData.definition.tokenDecimals,
        },
      },
      {
        onSuccess: (data) => {
          console.log("Asset watched successfully:", data)
        },
        onError: (error) => {
          console.error("Failed to watch the asset:", error)
        },
      }
    )
  }

  const greyInfoEntries = [
    stakingPoolData.data &&
      greyInfoEntry(
        "Voting Power",
        formatPercentage(stakingPoolData.data.votingPower),
        "Share of total staked ZIL controlled by the validator."
      ),

    stakingPoolData.data &&
      greyInfoEntry(
        isPoolLiquid() ? "Total Supply" : "Total Delegated",
        `${humanReadableStakingToken(stakingPoolData.data.tvl)} ${stakingPoolData.definition.tokenSymbol}`,
        isPoolLiquid()
          ? "The total supply of validator's Liquid Staking Token (LST)."
          : "Total ZIL staked through validator"
      ),

    stakingPoolData.data &&
      greyInfoEntry(
        "Commission",
        formatPercentage(stakingPoolData.data.commission),
        "Percentage of earned staking rewards paid to the validator."
      ),

    isPoolLiquid() &&
      stakingPoolData.data &&
      greyInfoEntry(
        "",
        <>
          1 {stakingPoolData.definition.tokenSymbol} = ~ <br />
          {formatUnitsWithMaxPrecision(
            convertTokenToZil(
              parseEther("1"),
              stakingPoolData.data.zilToTokenRate
            ),
            18,
            3
          )}{" "}
          ZIL
        </>,
        ""
      ),
  ]

  const availableEntries = greyInfoEntries.filter(Boolean)
  const columnCount = availableEntries.length
  const [isExpanded, setIsExpanded] = useState(true)

  const toggleExpand = () => {
    setIsExpanded(!isExpanded)
  }
  const { isWalletConnected } = WalletConnector.useContainer()
  const { stakingPoolForView } = StakingPoolsStorage.useContainer()
  const availableUnstake =
    userUnstakingPoolData
      ?.filter((claim) => claim.availableAt <= DateTime.now())
      .reduce((acc, claim) => acc + claim.zilAmount, 0n) || 0n

  const [isClicked, setIsClicked] = useState(false)

  const handleMouseDown = () => {
    setIsClicked(true)
  }

  const handleMouseUp = () => {
    setIsClicked(false)
  }

  const [isClickedClose, setIsClickedClose] = useState(false)

  const handleMouseDownClose = () => {
    setIsClickedClose(true)
  }

  const handleMouseUpClose = () => {
    setIsClickedClose(false)
  }

  return (
    <div className="relative pb-24 lg:pb-2 4k:pb-4 flex flex-col h-full ">
      <div className="items-center flex justify-between py-1 lg:py-7 px-4 lg:pr-2.5 4k:pr-6 xs:mx-5 lg:mx-7 4k:mx-10 ">
        <div className="max-lg:ms-1 items-center w-full flex justify-between mb-5">
          <div className="flex items-center">
            <span className="text-white1 bold33 lg:mr-6 mr-2">
              {stakingPoolData.definition.name}
            </span>

            {isPoolLiquid() && (
              <>
                <span className="lg:text-4xl text-xl lg:h4 text-gray3  font-light">
                  |
                </span>
                <span className="medium20 text-gray1 lg:ml-6 ml-2">
                  {stakingPoolData.definition.tokenSymbol}
                </span>
                <Tooltip
                  placement="top"
                  arrow={true}
                  overlayClassName="custom-tooltip"
                  title="Add token to wallet"
                >
                  <div
                    className={`ml-0.5 xxs:ml-4 rounded-160 border-[1px] border-transparent ${isClicked && "hover:!border-purplePrimary"}`}
                  >
                    <div
                      onMouseDown={handleMouseDown}
                      onMouseUp={handleMouseUp}
                      onClick={handleClickAddToken}
                      onMouseLeave={handleMouseUp}
                      className={`group btn-primary-purple px-0.5 xxs:px-1 py-0.5 xxs:py-1 border-purplePrimary border-[1px] flex items-center justify-center transition-all duration-300 cursor-pointer overflow-hidden
                        ${isClicked && "hover:!shadow-[0px_0px_0px_0px_#522EFF]"}`}
                    >
                      <Image
                        className="transition-all duration-300 flex-shrink-0 p-1"
                        src={PlusIcon}
                        alt="plus icon"
                        width={20}
                        height={20}
                      />
                      <div className="overflow-hidden transition-all duration-300 max-w-0 group-hover:max-w-28">
                        <span className="ml-1.5 mr-1 text-sm font-medium tracking-normal text-white1 whitespace-nowrap block transform translate-x-[-100%] group-hover:translate-x-0 transition-all duration-300 opacity-0 group-hover:opacity-100">
                          Add Token
                        </span>
                      </div>
                    </div>
                  </div>
                </Tooltip>
              </>
            )}
          </div>
          <div className="flex items-center">
            <div
              onMouseDown={handleMouseDownClose}
              onMouseUp={handleMouseUpClose}
              onMouseLeave={handleMouseUpClose}
              onClick={() => {
                selectStakingPoolForView(null)
              }}
              className={`group rounded-160 bg-gray3 text-white cursor-pointer duration-500 ease-in-out h-8 p-2.5 flex flex-row-reverse items-center justify-center transition-all
                ${isClickedClose && "bg-gray2"}`}
            >
              <Image
                className="flex-shrink-0 ml-0"
                src={CloseIcon}
                alt={"close icon"}
                width={12}
                height={12}
              />
              <div className="overflow-hidden transition-all duration-300 max-w-0 group-hover:max-w-16">
                <span className="ml-0.5 mr-2 text-sm text-white font-medium whitespace-nowrap block transform translate-x-full group-hover:translate-x-0 transition-all duration-300 opacity-0 group-hover:opacity-100">
                  Close
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <FastFadeScroll
        isPoolLiquid={stakingPoolData.definition.poolType}
        className="overflow-y-scroll max-lg:mx-2 lg:pr-5 4k:pr-6 xs:mx-5 lg:ml-7 lg:mr-5 4k:ml-12 4k:mr-6 "
      >
        {isPoolLiquid() ? (
          <div className="bg-grey-gradient  flex flex-col gap-2 px-2  max-lg:mt-5  rounded-xl">
            <div
              className={` ${doesUserHoldAnyFundsInThisPool ? "max-lg:pt-6 " : "py-6"} lg:py-6 4k:py-10 4k:px-16 lg:px-9 px-5`}
            >
              {doesUserHoldAnyFundsInThisPool && isWalletConnected && (
                <div
                  className={"flex flex-wrap max-lg:gap-y-4  4k:pb-6  pb-4 "}
                >
                  {colorInfoEntry(
                    "Available to Stake",
                    `${formatUnitsToHumanReadable(zilAvailable || 0n, 18)} ZIL`,
                    "Your ZIL balance"
                  )}
                  {colorInfoEntry(
                    "Staked",
                    `${humanReadableStakingToken(
                      userStakingPoolData?.stakingTokenAmount || 0n
                    )} ${stakingPoolData.definition.tokenSymbol}`,
                    <>
                      <div>Amount of ZIL currently staked</div>
                      {isPoolLiquid() &&
                        userStakingPoolData?.stakingTokenAmount &&
                        stakingPoolData.data != null && (
                          <div className="mt-1">
                            {`( ~ ${formatUnitsToHumanReadable(
                              convertTokenToZil(
                                userStakingPoolData.stakingTokenAmount,
                                stakingPoolData.data.zilToTokenRate
                              ),
                              18
                            )} ZIL )`}
                          </div>
                        )}
                    </>
                  )}
                  {colorInfoEntry(
                    "Unstaked ",
                    pendingUnstakesValue
                      ? `${humanReadableStakingToken(pendingUnstakesValue)} ZIL`
                      : "-",
                    <>
                      <div>
                        Amount of unstaked ZIL available after the unbonding
                        period
                      </div>
                    </>
                  )}
                  {colorInfoEntry(
                    "Claimable Withdrawals",
                    availableToClaim
                      ? `${humanReadableStakingToken(availableToClaim)} ZIL`
                      : "-",
                    "Unstaked ZIL available to claim"
                  )}
                </div>
              )}

              <div
                className={`flex flex-wrap justify-center  max-lg:gap-y-4  lg:text-left text-center ${doesUserHoldAnyFundsInThisPool && "max-lg:border-t  border-gradient-3 max-lg:pt-4 "}
               ${!isExpanded || (doesUserHoldAnyFundsInThisPool && "max-lg:hidden")} 
               ${columnCount < 4 && "!text-center"}`}
              >
                {availableEntries}
              </div>
            </div>
            {availableEntries &&
              availableEntries.length > 0 &&
              doesUserHoldAnyFundsInThisPool && (
                <>
                  <button
                    onClick={toggleExpand}
                    className="bg-custom-grey-gradient py-1 rounded-b-xl  items-center justify-center w-full mx-auto max-lg:flex hidden"
                  >
                    <Image
                      src={arrow}
                      width={12}
                      height={6}
                      alt="Arrow"
                      className={` w-3 h-2 transform transition-transform duration-300 ${
                        !isExpanded ? "rotate-180" : ""
                      }`}
                    />
                  </button>
                </>
              )}
          </div>
        ) : (
          <>
            <div className={" xl:flex hidden 4k:gap-5 gap-2 "}>
              <div
                className={` ${doesUserHoldAnyFundsInThisPool && isWalletConnected ? "w-2/3 " : "w-full"} bg-grey-gradient flex flex-col justify-center items-center  gap-2 max-xl:mt-5  rounded-xl`}
              >
                <div
                  className={`w-full ${doesUserHoldAnyFundsInThisPool ? "max-lg:pt-6 " : "py-6"} lg:py-6 4k:py-10 4k:px-16 lg:px-9 px-5`}
                >
                  {doesUserHoldAnyFundsInThisPool && isWalletConnected && (
                    <div
                      className={
                        "flex flex-wrap justify-center items-center max-lg:gap-y-4 4k:pb-6  pb-4 "
                      }
                    >
                      {colorInfoEntry(
                        "Available to stake",
                        `${formatUnitsToHumanReadable(zilAvailable || 0n, 18)} ZIL`,
                        "Your ZIL balance"
                      )}
                      {colorInfoEntry(
                        "Staked",
                        `${humanReadableStakingToken(
                          userStakingPoolData?.stakingTokenAmount || 0n
                        )} ${stakingPoolData.definition.tokenSymbol}`,
                        "Amount of ZIL currently staked"
                      )}
                      {colorInfoEntry(
                        "Unstaked",
                        pendingUnstakesValue
                          ? `${humanReadableStakingToken(
                              pendingUnstakesValue
                            )} ZIL`
                          : "-",
                        "Amount of unstaked ZIL available after the unbonding period"
                      )}
                    </div>
                  )}
                  <div
                    className={`flex flex-wrap  xl:text-left text-center  justify-center   max-lg:gap-y-4  ${doesUserHoldAnyFundsInThisPool && "max-lg:border-t  border-gradient-3 max-lg:pt-4 "}
               ${!isExpanded || (doesUserHoldAnyFundsInThisPool && "max-lg:hidden")}
               ${columnCount < 4 && !isWalletConnected && "!text-center"}`}
                  >
                    {availableEntries}
                  </div>
                </div>
              </div>
              {doesUserHoldAnyFundsInThisPool && isWalletConnected && (
                <div
                  className={
                    " flex bg-grey-gradient w-1/3  flex-col gap-2   max-xl:mt-5  rounded-xl"
                  }
                >
                  <div
                    className={` ${doesUserHoldAnyFundsInThisPool ? "max-xl:pt-6 " : "py-6"} lg:py-6 4k:py-10 4k:px-16 lg:px-9 px-5`}
                  >
                    {doesUserHoldAnyFundsInThisPool && isWalletConnected && (
                      <div
                        className={
                          "flex  flex-col flex-wrap gap-4 max-lg:gap-y-4     4k:pb-6   "
                        }
                      >
                        {asideColorInfoEntry(
                          "Claimable Withdrawals",
                          !!availableUnstake
                            ? `${formatUnitsToHumanReadable(availableUnstake, 18)} ZIL`
                            : "-",
                          "Unstaked ZIL available to claim"
                        )}
                        {stakingPoolForView != null &&
                          asideColorInfoEntry(
                            "Claimable Rewards",
                            stakingPoolForView.userData.reward
                              ? `${formatUnitsToHumanReadable(stakingPoolForView.userData.reward?.zilRewardAmount ?? "0", 18)} ZIL`
                              : "-",
                            "Earned ZIL available to claim"
                          )}
                      </div>
                    )}
                  </div>
                  {availableEntries &&
                    availableEntries.length > 0 &&
                    doesUserHoldAnyFundsInThisPool && (
                      <>
                        <button
                          onClick={toggleExpand}
                          className="bg-custom-grey-gradient py-1 rounded-b-xl  items-center justify-center w-full mx-auto max-xl:flex hidden"
                        >
                          <Image
                            src={arrow}
                            width={12}
                            height={6}
                            alt="Arrow"
                            className={` w-3 h-2 transform transition-transform duration-300 ${
                              !isExpanded ? "rotate-180" : ""
                            }`}
                          />
                        </button>
                      </>
                    )}
                </div>
              )}
            </div>
            <div className="bg-grey-gradient xl:hidden flex flex-col  gap-2  max-lg:mt-5  rounded-xl">
              <div
                className={` ${doesUserHoldAnyFundsInThisPool ? "max-xl:pt-6 " : "py-6"} xl:py-6 4k:py-10 4k:px-16 lg:px-9 px-5`}
              >
                {doesUserHoldAnyFundsInThisPool && isWalletConnected && (
                  <div
                    className={
                      "flex flex-wrap justify-center items-center max-xl:gap-y-4    4k:pb-6  pb-4 "
                    }
                  >
                    {colorInfoEntry(
                      "Available to stake",
                      `${formatUnitsToHumanReadable(zilAvailable || 0n, 18)} ZIL staked`,
                      "Your ZIL balance"
                    )}
                    {colorInfoEntry(
                      "Staked",
                      `${humanReadableStakingToken(
                        userStakingPoolData?.stakingTokenAmount || 0n
                      )} ${stakingPoolData.definition.tokenSymbol}`,
                      "Amount of ZIL currently staked"
                    )}
                    {colorInfoEntry(
                      "Unstaked",
                      pendingUnstakesValue
                        ? `${humanReadableStakingToken(
                            pendingUnstakesValue
                          )} ZIL`
                        : "-",
                      "Amount of unstaked ZIL available after the unbonding period"
                    )}
                    {stakingPoolForView != null &&
                      colorInfoEntry(
                        "Claimable Rewards",
                        stakingPoolForView.userData.reward
                          ? `${formatUnitsToHumanReadable(stakingPoolForView.userData.reward?.zilRewardAmount ?? "0", 18)} ZIL`
                          : "-",
                        "Earned ZIL available to claim"
                      )}
                  </div>
                )}
                <div
                  className={`flex flex-wrap justify-center  max-xl:gap-y-4  xl:text-left text-center ${doesUserHoldAnyFundsInThisPool && "max-xl:border-t  border-gradient-3 max-xl:pt-4 "}
             ${!isExpanded || (doesUserHoldAnyFundsInThisPool && "max-xl:hidden")}
             ${columnCount < 4 && !isWalletConnected && "!text-center"}`}
                >
                  {availableEntries}
                </div>
              </div>
              {availableEntries &&
                availableEntries.length > 0 &&
                doesUserHoldAnyFundsInThisPool && (
                  <>
                    <button
                      onClick={toggleExpand}
                      className="bg-custom-grey-gradient py-1 rounded-b-xl  items-center justify-center w-full mx-auto max-xl:flex hidden"
                    >
                      <Image
                        src={arrow}
                        width={12}
                        height={6}
                        alt="Arrow"
                        className={` w-3 h-2 transform transition-transform duration-300 ${
                          !isExpanded ? "rotate-180" : ""
                        }`}
                      />
                    </button>
                  </>
                )}
            </div>
          </>
        )}

        <div className="lg:mx-10 mx-3 grid grid-cols-3 my-4 lg:gap-20 gap-5">
          {["Stake", "Unstake", "Claim"].map((pane) => (
            <div
              key={pane}
              className={`semi13 text-center py-2 4k:py-6 cursor-pointer border-solid border-b transition-all duration-400 ease-in-out relative ${
                selectedPane === pane
                  ? "text-white1 border-black1 after:bg-colorful-gradient after:absolute after:h-[1px] after:w-0 after:bottom-0 after:left-0 after:animate-grow-width after:transition-all after:duration-300 before:bg-white before:absolute before:h-[1px] before:w-full before:bottom-0 before:left-0"
                  : "text-gray3 border-black1 hover:text-white after:bg-white after:absolute after:h-[1px] after:w-0 after:bottom-0 after:left-0 hover:after:w-full after:transition-all after:duration-300"
              } `}
              onClick={() => setSelectedPane(pane)}
            >
              {pane}
            </div>
          ))}
        </div>

        <div className="flex-1 pb-10 mb-6 lg:mb-0 ">
          {selectedPane === "Stake" ? (
            <StakingCalculator />
          ) : selectedPane === "Unstake" ? (
            <UnstakingCalculator />
          ) : (
            <WithdrawZilPanel
              userUnstakingPoolData={userUnstakingPoolData}
              stakingPoolData={stakingPoolData}
              reward={reward}
            />
          )}
        </div>
      </FastFadeScroll>
    </div>
  )
}

export default StakingPoolDetailsView

```

`src/components/stakingPoolsList.tsx`:

```tsx
import { StakingPoolsStorage } from "@/contexts/stakingPoolsStorage"
import StakingPoolCard from "@/components/stakingPoolCard"
import SortBtn from "@/components/sortBtn"
import { Dispatch, SetStateAction, useEffect, useMemo, useState } from "react"
import { StakingPoolType } from "@/misc/stakingPoolsConfig"
import FastFadeScroll from "@/components/fastFadeScroll"
import { Tooltip } from "antd"

interface StakingPoolsListProps {
  setViewClaim: Dispatch<SetStateAction<boolean>>
  selectedPoolType: StakingPoolType
  setSelectedPoolType: Dispatch<SetStateAction<StakingPoolType>>
}

const StakingPoolsList: React.FC<StakingPoolsListProps> = ({
  setViewClaim,
  selectedPoolType,
  setSelectedPoolType,
}) => {
  const {
    combinedStakingPoolsData,
    selectStakingPoolForView,
    stakingPoolForView,
  } = StakingPoolsStorage.useContainer()

  const [sortCriteria, setSortCriteria] = useState<
    "APR" | "VP" | "Commission" | null
  >(null)
  const [isAscending, setIsAscending] = useState(true)

  // Function to get the value to sort by based on the criteria
  const getSortValue = (data: any, criteria: string | null) => {
    if (!data) return 0

    switch (criteria) {
      case "APR":
        return data.apr || 0
      case "VP":
        return (data.votingPower || 0) * 100
      case "Commission":
        return (data.commission || 0) * 100

      default:
        return 0
    }
  }

  const orderBySortCriteria = (a: any, b: any) => {
    const aValue = getSortValue(a.stakingPool.data, sortCriteria)
    const bValue = getSortValue(b.stakingPool.data, sortCriteria)
    return isAscending ? aValue - bValue : bValue - aValue
  }

  const sortedLiquidStakingPoolsData = useMemo(
    () =>
      combinedStakingPoolsData
        .filter(
          (pool) => pool.stakingPool.definition.poolType === selectedPoolType
        )
        .toSorted(orderBySortCriteria),
    [combinedStakingPoolsData, sortCriteria, isAscending, selectedPoolType]
  )

  const handleSortClick = (criteria: "APR" | "VP" | "Commission") => {
    if (sortCriteria === criteria) {
      setIsAscending(!isAscending)
    } else {
      setSortCriteria(criteria)
      setIsAscending(true)
    }
  }

  const tabs = [
    {
      name: "Liquid",
      type: StakingPoolType.LIQUID,
      tooltip: "Stake and keep liquidity",
    },
    {
      name: "Non-Liquid ",
      type: StakingPoolType.NORMAL,
      tooltip: "Lock assets and claim rewards",
    },
  ]

  return (
    <>
      <nav aria-label="Tabs" className="w-full flex  px-4 xs:px-6 4k:px-10">
        {tabs.map((tab, index) => (
          <Tooltip
            placement="top"
            arrow={true}
            overlayClassName="custom-tooltip"
            className=" mr-1"
            title={tab.tooltip}
            key={index}
          >
            <button
              className={`w-1/2 whitespace-nowrap py-3 4k:py-4 border-solid border-b transition-all duration-400 ease-in-out relative min-h-[60px] lg:min-h-[65px] 
                after:transition-all after:duration-300 after:bottom-0 after:absolute border-black1
                ${tab.type === StakingPoolType.LIQUID ? "after:bg-tealPrimary after:right-0" : "after:bg-purplePrimary after:left-0"}
          ${
            selectedPoolType === tab.type
              ? "bold33 text-white1 after:h-[1px] after:w-full "
              : `bold22 text-gray3 hover:text-white after:h-[1px] after:w-0 hover:after:w-full  ${
                  tab.type === StakingPoolType.LIQUID
                    ? "after:right-0"
                    : "after:left-0"
                }`
          } `}
              onClick={() => {
                setSelectedPoolType(tab.type)
                selectStakingPoolForView(null)
              }}
            >
              {tab.name}
            </button>
          </Tooltip>
        ))}
      </nav>

      <>
        <div className="flex gap-x-2.5 mt-3 4k:mt-6 mb-2.5 4k:mb-5 max-h-[5vh] mx-3 lg:mx-2 xl:mx-5 4k:mx-6  px-4 xs:px-6 4k:px-10">
          <SortBtn
            liquidType={selectedPoolType === StakingPoolType.LIQUID}
            variable="APR"
            isClicked={isAscending && sortCriteria == "APR"}
            onClick={() => handleSortClick("APR")}
            tooltip="Annual Percentage Rate"
          />
          <SortBtn
            liquidType={selectedPoolType === StakingPoolType.LIQUID}
            variable="VP"
            isClicked={isAscending && sortCriteria == "VP"}
            onClick={() => handleSortClick("VP")}
            tooltip="Voting Power - Share of total staked ZIL controlled by the validator."
          />
          <SortBtn
            liquidType={selectedPoolType === StakingPoolType.LIQUID}
            variable="Commission"
            isClicked={isAscending && sortCriteria == "Commission"}
            onClick={() => handleSortClick("Commission")}
            tooltip="Percentage of your staking rewards paid to the validator."
          />
        </div>

        <FastFadeScroll
          isPoolLiquid={stakingPoolForView?.stakingPool.definition.poolType}
          className="flex-1 pb-8 lg:pb-4 mb-16 md:mb-0 overflow-y-scroll  mx-2 xs:mx-3 4k:mx-5"
        >
          <div className="grid grid-cols-1 gap-2.5 lg:gap-4 4k:gap-5 px-2 xs:px-3 4k:px-5">
            {sortedLiquidStakingPoolsData.map(({ stakingPool, userData }) => (
              <StakingPoolCard
                key={stakingPool.definition.id}
                stakingPoolData={stakingPool}
                userStakingPoolData={userData}
                isStakingPoolSelected={
                  stakingPoolForView?.stakingPool.definition.id ===
                  stakingPool.definition.id
                }
                onClick={() => {
                  selectStakingPoolForView(stakingPool.definition.id)
                  setViewClaim(false)
                }}
              />
            ))}
          </div>
        </FastFadeScroll>
      </>
    </>
  )
}

export default StakingPoolsList

```

`src/components/unstakingCalculator.tsx`:

```tsx
import { StakingPoolsStorage } from "@/contexts/stakingPoolsStorage"
import { useEffect, useRef, useState } from "react"
import { Button, Input, InputRef, Tooltip } from "antd"
import {
  formatPercentage,
  convertTokenToZil,
  formatUnitsToHumanReadable,
  getHumanFormDuration,
  formatUnitsWithMaxPrecision,
} from "@/misc/formatting"
import { formatUnits, parseEther, parseUnits } from "viem"
import { StakingOperations } from "@/contexts/stakingOperations"
import { DateTime } from "luxon"
import { StakingPoolType } from "@/misc/stakingPoolsConfig"
import FastFadeScroll from "@/components/fastFadeScroll"
import { WalletConnector } from "@/contexts/walletConnector"
import CustomWalletConnect from "@/components/customWalletConnect"
import LastTransaction from "@/components/lastTransaction"

const UnstakingCalculator: React.FC = () => {
  const inputRef = useRef<InputRef | null>(null)

  const { isWalletConnected } = WalletConnector.useContainer()
  const { stakingPoolForView } = StakingPoolsStorage.useContainer()

  const [isFocused, setIsFocused] = useState(true)

  const {
    unstake,
    isUnstakingInProgress,
    unstakingCallTxHash,
    unstakeContractCallError,
    unstakingCallZilFees,
    preparingUnstakingTx,
  } = StakingOperations.useContainer()

  const [tokensToUnstake, setZilToUnstake] = useState<string>("0")

  const stakedTokenAvailable =
    stakingPoolForView?.userData?.staked?.stakingTokenAmount || 0n
  const poolTokenDecimals =
    stakingPoolForView?.stakingPool.definition.tokenDecimals || 18

  const maxValue = formatUnits(stakedTokenAvailable, poolTokenDecimals)
  const onMaxClick = () => {
    setZilToUnstake(maxValue)

    setIsMaxValue(true)
    setIsMinValue(false)
  }

  const [isMinValue, setIsMinValue] = useState(false)
  const [isMaxValue, setIsMaxValue] = useState(false)

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { value: inputValue } = e.target
    const reg = /^-?\d*(\.\d*)?$/
    if (reg.test(inputValue) || inputValue === "" || inputValue === "-") {
      setIsMinValue(inputValue === "1")
      setIsMaxValue(inputValue === maxValue)

      console.log(isMinValue, "min and ", isMaxValue, "max")
      setZilToUnstake(inputValue)
    }
  }

  const handleFocus = () => {
    setIsFocused(true)
  }

  const handleBlur = () => {
    let valueTemp = tokensToUnstake
    if (
      tokensToUnstake.charAt(tokensToUnstake.length - 1) === "." ||
      tokensToUnstake === "-"
    ) {
      valueTemp = tokensToUnstake.slice(0, -1)
    }
    setZilToUnstake(valueTemp.replace(/0*(\d+)/, "$1"))
    setIsFocused(false)
  }

  const tokenToUnstakeInBaseUnit = parseUnits(
    tokensToUnstake,
    poolTokenDecimals
  )

  const unboudingPeriod = getHumanFormDuration(
    DateTime.now().plus({
      minutes:
        stakingPoolForView?.stakingPool.definition.withdrawPeriodInMinutes || 0,
    })
  )

  useEffect(() => {
    if (isFocused && inputRef.current) {
      inputRef.current.focus()
    }
  }, [isFocused])

  const isPoolLiquid = () =>
    stakingPoolForView?.stakingPool.definition.poolType ===
    StakingPoolType.LIQUID

  const isUnstakingAvailable =
    (stakingPoolForView?.userData.staked?.stakingTokenAmount || 0n) !== 0n

  const { canUnstake, whyCantUnstake } = (() => {
    if (!stakingPoolForView?.stakingPool.data) {
      return {
        canUnstake: false,
        whyCantUnstake: "Loading staking data",
      }
    } else if (!isUnstakingAvailable) {
      return {
        canUnstake: false,
        whyCantUnstake: "No staked balance",
      }
    } else if (tokenToUnstakeInBaseUnit <= 0n) {
      return {
        canUnstake: false,
        whyCantUnstake: "Enter a valid amount",
      }
    } else if (stakedTokenAvailable < tokenToUnstakeInBaseUnit) {
      return {
        canUnstake: false,
        whyCantUnstake: "Insufficient staked balance",
      }
    } else {
      return {
        canUnstake: true,
        whyCantUnstake: "Claimable after unbonding period",
      }
    }
  })()

  const [isMinHovered, setIsMinHovered] = useState(false)
  const [isMaxHovered, setIsMaxHovered] = useState(false)

  return (
    stakingPoolForView && (
      <FastFadeScroll
        isPoolLiquid={stakingPoolForView?.stakingPool.definition.poolType}
        className={"flex-1 overflow-y-scroll"}
      >
        <Tooltip
          placement="bottomLeft"
          arrow={true}
          overlayClassName="custom-tooltip"
          className=""
          title={
            !isWalletConnected
              ? "Please connect your wallet first."
              : isUnstakingAvailable
                ? "Enter amount to unstake."
                : "You'll need to stake first."
          }
        >
          <div
            className={`transition-all duration-300 border-transparent bg-gray-gradient 
              ${
                isUnstakingAvailable &&
                ` 
                  ${isFocused && "ant-input-affix-wrapper-focused !border-transparent !bg-focus-gradient "}
                  ${isMaxValue && "bg-teal-gradient !border-teal"}
                  ${isMaxHovered && "!bg-teal-gradient"}
                  ${isMinValue && "bg-purple-gradient"}
                  ${isMinHovered && "!bg-purple-gradient"}
                  ${!canUnstake && tokensToUnstake != "0" && tokensToUnstake != "" && "!bg-red-gradient"}`
              }
              flex justify-between lg:gap-10 4k:gap-14 mb-2.5 lg:mb-4 4k:mb-6 p-3 lg:p-5 xl:p-7 4k:p-10 rounded-xl items-center`}
          >
            <div className="h-fit self-center">
              <div className=" flex items-center gap-2">
                <div
                  className={`${
                    !isWalletConnected || !isUnstakingAvailable
                      ? "text-gray3"
                      : "text-white1"
                  } bold33`}
                >
                  {" "}
                  {stakingPoolForView.stakingPool.definition.tokenSymbol}{" "}
                </div>

                <Input
                  ref={inputRef}
                  className={`${
                    tokensToUnstake === "0" || tokensToUnstake === ""
                      ? "text-gray2"
                      : "text-white1"
                  }   ${
                    !isWalletConnected || !isUnstakingAvailable
                      ? "placeholder-gray3"
                      : "placeholder-gray2 "
                  } flex items-baseline !bg-transparent !border-transparent !shadow-none bold33 px-0`}
                  value={tokensToUnstake !== "0" ? tokensToUnstake || "" : ""}
                  placeholder="0"
                  onChange={handleChange}
                  onBlur={handleBlur}
                  onFocus={handleFocus}
                  status={!canUnstake ? "error" : undefined}
                  disabled={!isUnstakingAvailable || isUnstakingInProgress}
                />
              </div>
              <div className="flex items-center ">
                {isPoolLiquid() && (
                  <span
                    className={` mr-3 ${
                      !isWalletConnected ||
                      (!isUnstakingAvailable && "text-gray3")
                    } medium17`}
                  >
                    {stakingPoolForView!.stakingPool.data ? (
                      <>
                        {" "}
                        ~
                        {formatUnitsToHumanReadable(
                          convertTokenToZil(
                            tokenToUnstakeInBaseUnit,
                            stakingPoolForView.stakingPool.data.zilToTokenRate
                          ),
                          18
                        )}
                      </>
                    ) : (
                      <div className="loading-blur ">00</div>
                    )}{" "}
                    ZIL
                  </span>
                )}

                <span
                  className={`${
                    !isWalletConnected || !isUnstakingAvailable
                      ? "text-gray3"
                      : !isUnstakingAvailable
                        ? "!text-gray2"
                        : isPoolLiquid()
                          ? "text-tealPrimary"
                          : "text-purple2"
                  } medium17`}
                >
                  {unboudingPeriod}
                </span>
              </div>
            </div>
            <div className="flex flex-col gap-3">
              <Button
                className={`btn-secondary-teal ${isMaxValue && "!border-tealPrimary"}`}
                onClick={onMaxClick}
                onMouseEnter={() => setIsMaxHovered(true)}
                onMouseLeave={() => setIsMaxHovered(false)}
                disabled={!isUnstakingAvailable || isUnstakingInProgress}
              >
                MAX
              </Button>
              <Button
                className={`btn-secondary-purple ${isMinValue && "!border-purplePrimary"}`}
                onClick={() => {
                  setZilToUnstake("1")
                  setIsMinValue(true)
                  setIsMaxValue(false)
                }}
                onMouseEnter={() => setIsMinHovered(true)}
                onMouseLeave={() => setIsMinHovered(false)}
                disabled={!isUnstakingAvailable || isUnstakingInProgress}
              >
                MIN
              </Button>
            </div>
          </div>
        </Tooltip>
        <div className="flex flex-col justify-between">
          <div className="flex mt-2 mb-3">
            {isWalletConnected ? (
              <Tooltip
                placement="top"
                arrow={true}
                overlayClassName="custom-tooltip"
                title={whyCantUnstake}
              >
                <Button
                  type="default"
                  size="large"
                  className={`${
                    isPoolLiquid()
                      ? "btn-primary-teal-lg lg:btn-primary-teal"
                      : "btn-primary-purple-lg lg:btn-primary-purple"
                  }  mx-auto lg:w-1/2 w-2/3`}
                  disabled={!canUnstake}
                  onClick={() =>
                    unstake(
                      stakingPoolForView.stakingPool.definition.address,
                      tokenToUnstakeInBaseUnit
                    )
                  }
                  loading={isUnstakingInProgress}
                >
                  {preparingUnstakingTx
                    ? "Confirm in wallet"
                    : isUnstakingInProgress
                      ? "Processing"
                      : "Unstake"}
                </Button>
              </Tooltip>
            ) : (
              <CustomWalletConnect notConnectedClassName="btn-primary-teal sm:px-10 sm:max-w-fit  mx-auto lg:w-1/2 w-2/3">
                Connect wallet
              </CustomWalletConnect>
            )}
          </div>

          <LastTransaction txHash={unstakingCallTxHash} />

          <div className="flex justify-between pt-2.5 lg:pt-5 4k:pt-7 mt-2.5 lg:mt-4 4k:mt-6 border-t border-black1 lg:pb-10">
            <div className="flex flex-col lg:gap-2.5 gap-1 regular-base">
              <div className=" ">
                Commission Fee:{" "}
                {stakingPoolForView!.stakingPool.data ? (
                  <>
                    {" "}
                    {formatPercentage(
                      stakingPoolForView!.stakingPool.data.commission
                    )}{" "}
                  </>
                ) : (
                  <div className="loading-blur">1.1% </div>
                )}
              </div>
              <div className="">
                Max transaction cost: ~{unstakingCallZilFees} ZIL
              </div>
              <div
                className={`${isPoolLiquid() ? "text-tealPrimary" : "text-purple2"} `}
              >
                <Tooltip
                  placement="top"
                  arrow={true}
                  overlayClassName="custom-tooltip"
                  className=""
                  title="How long before you can claim your ZIL after unstaking."
                >
                  <span>Unbonding Period: {unboudingPeriod}</span>
                </Tooltip>
              </div>
            </div>
            <div className="flex flex-col lg:gray-base gray-base2 xl:gap-2.5 4k:gap-5 xl:items-end justify-start">
              {isPoolLiquid() && (
                <div className="flex flex-col max-xl:justify-between  max-lg:items-start xl:gap-3.5 xl:items-end">
                  <div className="flex   xl:gap-5 4k:gap-6">
                    <div className="lg:gray-base">Rate</div>
                    <div className="text-gray1">
                      {stakingPoolForView!.stakingPool.data ? (
                        <>
                          1{" "}
                          {
                            stakingPoolForView.stakingPool.definition
                              .tokenSymbol
                          }{" "}
                          =~
                          {formatUnitsWithMaxPrecision(
                            convertTokenToZil(
                              parseEther("1"),
                              stakingPoolForView.stakingPool.data.zilToTokenRate
                            ),
                            18,
                            5
                          )}{" "}
                          ZIL
                        </>
                      ) : (
                        <div className="loading-blur "> 1Zil =~ 1zil</div>
                      )}
                    </div>
                  </div>
                </div>
              )}

              <div className="text-gray1 flex flex-row xl:gap-5 4k:gap-6">
                <Tooltip
                  placement="top"
                  arrow={true}
                  overlayClassName="custom-tooltip"
                  className=" mr-1"
                  title="Annual Percentage Rate"
                >
                  <span className="lg:gray-base  ">APR </span>
                </Tooltip>

                {stakingPoolForView!.stakingPool.data ? (
                  <>
                    ~
                    {formatPercentage(stakingPoolForView!.stakingPool.data.apr)}
                  </>
                ) : (
                  <div className="loading-blur  "> ~11%</div>
                )}
              </div>
            </div>
          </div>
        </div>

        {unstakeContractCallError && (
          <div className="text-red1 text-center">
            {unstakeContractCallError.message}
          </div>
        )}
      </FastFadeScroll>
    )
  )
}

export default UnstakingCalculator

```

`src/components/withdrawUnstakedZilPanel.tsx`:

```tsx
import { StakingOperations } from "@/contexts/stakingOperations"
import { StakingPoolsStorage } from "@/contexts/stakingPoolsStorage"

import {
  formatUnitsToHumanReadable,
  getHumanFormDuration,
} from "@/misc/formatting"
import { StakingPool, StakingPoolType } from "@/misc/stakingPoolsConfig"
import {
  UserNonLiquidStakingPoolRewardData,
  UserUnstakingPoolData,
} from "@/misc/walletsConfig"
import { Button, Tooltip } from "antd"
import { DateTime } from "luxon"
import { formatUnits } from "viem"
import LastTransaction from "@/components/lastTransaction"

interface WithdrawZilPanelProps {
  stakingPoolData: StakingPool
  userUnstakingPoolData?: Array<UserUnstakingPoolData>
  reward?: UserNonLiquidStakingPoolRewardData
}

const WithdrawZilPanel: React.FC<WithdrawZilPanelProps> = ({
  userUnstakingPoolData,
  stakingPoolData,
  reward,
}) => {
  const {
    claimUnstake,
    isClaimingUnstakeInProgress,
    claimUnstakeCallTxHash,
    preparingClaimUnstakeTx,
    claimReward,
    isClaimingRewardInProgress,
    claimRewardCallTxHash,
    preparingClaimRewardTx,
    stakeReward,
    isStakingRewardInProgress,
    stakeRewardCallTxHash,
    preparingStakeRewardTx,
  } = StakingOperations.useContainer()

  const { getMinimalPoolStakingAmount } = StakingPoolsStorage.useContainer()

  const pendingUnstake = userUnstakingPoolData
    ?.filter((claim) => claim.availableAt > DateTime.now())
    .toSorted(
      (claimA, claimB) =>
        claimA.availableAt.diff(claimB.availableAt).milliseconds
    )

  const availableUnstake =
    userUnstakingPoolData
      ?.filter((claim) => claim.availableAt <= DateTime.now())
      .reduce((acc, claim) => acc + claim.zilAmount, 0n) || 0n

  const hashToShow =
    claimRewardCallTxHash || stakeRewardCallTxHash || claimUnstakeCallTxHash

  const otherPendingClaimsToShow =
    availableUnstake > 0n ? pendingUnstake : pendingUnstake?.slice(1)

  return (
    <div className="h-full">
      <LastTransaction txHash={hashToShow} />

      {reward && (
        <div
          className=" min-h-[100px] lg:min-h-[124px] xl:min-h-[140px] 
            flex flex-col justify-evenly gap-2 4k:gap-3 mb-2.5 lg:mb-4 4k:mb-6 p-3 lg:p-5 xl:p-7 4k:p-10 bg-grey-gradient rounded-xl w-full"
        >
          <div className="items-center h4 w-full flex justify-between text-white1">
            {stakingPoolData.data ? (
              <div>
                <div className="body2">
                  <span
                    className={`${
                      stakingPoolData.definition.poolType ===
                      StakingPoolType.LIQUID
                        ? "text-tealPrimary"
                        : "text-purple3"
                    }`}
                  >
                    Claimable Rewards
                  </span>
                </div>
                <div>
                  {`${formatUnitsToHumanReadable(reward.zilRewardAmount, 18)} ZIL`}
                </div>
              </div>
            ) : (
              <div className="loading-blur"> 00000 zil</div>
            )}
            <div className=" lg:w-1/3 max-w-[150px] sm:max-w-[250px] w-full">
              {getMinimalPoolStakingAmount(reward.address) >
              reward.zilRewardAmount ? (
                <Tooltip
                  placement="top"
                  arrow={true}
                  overlayClassName="custom-tooltip"
                  className="mr-1"
                  title={`Reward is less than the minimal staking amount of ${formatUnitsToHumanReadable(
                    getMinimalPoolStakingAmount(reward.address),
                    18
                  )} ZIL`}
                >
                  <Button
                    className={` 
                      ${
                        isStakingRewardInProgress
                          ? stakingPoolData.definition.poolType ===
                            StakingPoolType.LIQUID
                            ? "liquid-loading"
                            : "non-liquid-loading"
                          : ""
                      }
                      ${stakingPoolData.definition.poolType === StakingPoolType.LIQUID ? " liquid-hover" : " non-liquid-hover"} btn-primary-grey lg:py-5 py-4 mb-2.5`}
                    onClick={() => stakeReward(reward.address)}
                    loading={isStakingRewardInProgress}
                    disabled={true}
                  >
                    Stake Reward
                  </Button>
                </Tooltip>
              ) : (
                <Button
                  className={` 
                    ${
                      isStakingRewardInProgress
                        ? stakingPoolData.definition.poolType ===
                          StakingPoolType.LIQUID
                          ? "liquid-loading"
                          : "non-liquid-loading"
                        : ""
                    }
                    ${stakingPoolData.definition.poolType === StakingPoolType.LIQUID ? " liquid-hover" : " non-liquid-hover"} btn-primary-grey lg:py-5 py-4 mb-2.5`}
                  onClick={() => stakeReward(reward.address)}
                  loading={isStakingRewardInProgress}
                >
                  {preparingStakeRewardTx
                    ? "Confirm in wallet"
                    : isStakingRewardInProgress
                      ? "Processing"
                      : "Stake Reward"}
                </Button>
              )}

              <Button
                className={` 
                  ${
                    isClaimingRewardInProgress
                      ? stakingPoolData.definition.poolType ===
                        StakingPoolType.LIQUID
                        ? "liquid-loading"
                        : "non-liquid-loading"
                      : ""
                  }
                  ${stakingPoolData.definition.poolType === StakingPoolType.LIQUID ? " liquid-hover" : " non-liquid-hover"}
                   ${
                     getMinimalPoolStakingAmount(reward.address) >
                     reward.zilRewardAmount
                       ? " btn-primary-grey "
                       : " btn-secondary-grey "
                   }
                 lg:py-5 py-4`}
                onClick={() => claimReward(reward.address)}
                loading={isClaimingRewardInProgress}
              >
                {preparingClaimRewardTx
                  ? "Confirm in wallet"
                  : isClaimingRewardInProgress
                    ? "Processing"
                    : "Claim Reward"}
              </Button>
            </div>
          </div>
        </div>
      )}

      {availableUnstake > 0n ? (
        <div
          className=" min-h-[100px] lg:min-h-[124px] xl:min-h-[140px] 
          flex flex-col justify-evenly gap-2 4k:gap-3 mb-2.5 lg:mb-4 4k:mb-6 p-3 lg:p-5 xl:p-7 4k:p-10 bg-grey-gradient rounded-xl w-full"
        >
          <div className="items-center h4 w-full flex justify-between text-white1">
            {stakingPoolData.data ? (
              <div>
                <div className="body2">
                  <span
                    className={`${
                      stakingPoolData.definition.poolType ===
                      StakingPoolType.LIQUID
                        ? "text-tealPrimary"
                        : "text-purple3"
                    }`}
                  >
                    Claimable Withdrawals
                  </span>
                </div>
                <div>
                  {formatUnitsToHumanReadable(availableUnstake, 18)} ZIL
                </div>
              </div>
            ) : (
              <div className="loading-blur">000.000 ZIL</div>
            )}
            <div className="max-lg:gap-2.5 max-lg:flex lg:w-1/3 max-w-[150px] sm:max-w-[250px] w-full">
              <Button
                className={` 
                  ${
                    isClaimingUnstakeInProgress
                      ? stakingPoolData.definition.poolType ===
                        StakingPoolType.LIQUID
                        ? "liquid-loading"
                        : "non-liquid-loading"
                      : ""
                  }
                  ${stakingPoolData.definition.poolType === StakingPoolType.LIQUID ? " liquid-hover" : " non-liquid-hover"} btn-primary-grey lg:py-5 py-4`}
                onClick={() => claimUnstake(stakingPoolData.definition.address)}
                loading={isClaimingUnstakeInProgress}
              >
                {preparingClaimUnstakeTx
                  ? "Confirm in wallet"
                  : isClaimingUnstakeInProgress
                    ? "Processing"
                    : "Claim"}
              </Button>
            </div>
          </div>
        </div>
      ) : !!pendingUnstake?.length ? (
        <div
          className="flex flex-col min-h-[100px] lg:min-h-[132px] xl:min-h-[148px] justify-evenly  
         mb-2.5 lg:mb-4 4k:mb-6 py-2 lg:py-6 xl:py-8 4k:py-10 
         px-3 lg:px-7 xl:px-10 4k:px-14 bg-grey-gradient rounded-xl w-full"
        >
          <div className="body2 text-gray3">
            Next available withdrawal claim
          </div>
          <div className="h4 mt-2 w-full flex justify-between text-white1">
            <div>{getHumanFormDuration(pendingUnstake[0].availableAt)}</div>
            {stakingPoolData.data ? (
              <div>
                {parseFloat(
                  formatUnits(pendingUnstake[0].zilAmount, 18)
                ).toFixed(3)}{" "}
                ZIL
              </div>
            ) : (
              <div className="loading-blur">00.000</div>
            )}
          </div>
        </div>
      ) : !reward ? (
        <div className="flex justify-center items-center h-full body2 text-gray3 ">
          No available Claims
        </div>
      ) : (
        <></>
      )}

      {!!otherPendingClaimsToShow && (
        <div className="mt-3 ">
          <div className="info-label mb-3">Other pending claims</div>

          {otherPendingClaimsToShow.map((claim, claimIdx) => (
            <div
              className="flex justify-between mb-3 items-center"
              key={claimIdx}
            >
              {stakingPoolData.data ? (
                <div className="flex gap-2.5">
                  <div className="body1 text-white1">
                    {parseFloat(formatUnits(claim.zilAmount, 18)).toFixed(3)}{" "}
                    ZIL
                  </div>
                </div>
              ) : (
                <div className="loading-blur">00.000 ZIL</div>
              )}
              <div className="regular-base text-white1">
                {getHumanFormDuration(claim.availableAt)}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

export default WithdrawZilPanel

```

`src/components/withdrawZilView.tsx`:

```tsx
import { StakingOperations } from "@/contexts/stakingOperations"
import { StakingPoolsStorage } from "@/contexts/stakingPoolsStorage"
import rewards from "../assets/svgs/rewards.svg"
import requests from "../assets/svgs/requests.svg"

import {
  formatUnitsToHumanReadable,
  getHumanFormDuration,
} from "@/misc/formatting"
import FeedbackIcon from "../assets/svgs/feedback-icon.svg"
import { StakingPool, StakingPoolType } from "@/misc/stakingPoolsConfig"
import {
  UserNonLiquidStakingPoolRewardData,
  UserUnstakingPoolData,
} from "@/misc/walletsConfig"
import { Button, Tooltip } from "antd"
import Image from "next/image"
import { Dispatch, SetStateAction, useState } from "react"
import FilterBtn from "@/components/filterBtn"
import FastFadeScroll from "@/components/fastFadeScroll"
import { showNewMessage } from "@intercom/messenger-js-sdk"

interface UnstakeCardProps {
  available: boolean
  unstakeInfo: UserUnstakingPoolData
  stakingPool: StakingPool
  selectStakingPoolForView: (stakingPoolId: string | null) => void
  claimUnstake: (delegatorAddress: string) => void
  setViewClaim: Dispatch<SetStateAction<boolean>>
}

const UnstakeCard: React.FC<UnstakeCardProps> = ({
  available,
  unstakeInfo,
  stakingPool,
  selectStakingPoolForView,
  claimUnstake,
  setViewClaim,
}) => {
  const {
    preparingClaimUnstakeTx,
    isClaimingUnstakeInProgress,
    stakingPoolIdForInProgressOperation,
  } = StakingOperations.useContainer()

  const isCurrentWalletOperationAboutThisPool =
    stakingPoolIdForInProgressOperation === stakingPool.definition.id
  const isInProgress =
    isClaimingUnstakeInProgress && isCurrentWalletOperationAboutThisPool

  return (
    <div
      className={` ${stakingPool.definition.poolType != StakingPoolType.LIQUID ? "purple-border-bottom" : "teal-border-bottom"}  flex gap-2.5 4k:gap-3 lg:w-full max-lg:flex-col bg-aqua-gradient rounded-[20px] items-center cursor-pointer lg:justify-between`}
      onClick={() => {
        selectStakingPoolForView(stakingPool.definition.id)
        setViewClaim(true)
      }}
    >
      <div
        className={
          "flex lg:flex-col  content-center  max-lg:px-3 py-6 4k:py-7 lg:pl-9 4k:pl-12 rounded-lg justify-between max-lg:items-center lg:w-2/3 w-full"
        }
      >
        <div className="flex items-center gap-2 4k:gap-2.5">
          <Image
            className="rounded"
            src={stakingPool.definition.iconUrl}
            alt={`${stakingPool.definition.name} icon`}
            width={31}
            height={31}
          />
          <div className="semi24">{stakingPool.definition.name}</div>
          <div className="text-gray3 lg:hidden text-xl">|</div>
          {stakingPool.definition.poolType != StakingPoolType.LIQUID && (
            <div className="bg-gray3 text-white1 py-1 4k:py-1.5 px-2 4k:px-2.5 items-center gap-2 4k:gap-2.5 medium12 flex ">
              <Image
                className="rounded"
                src={requests}
                alt="requests"
                width={14}
                height={15}
              />
              Withdrawals
            </div>
          )}
        </div>
        <div className="flex lg:mt-3 items-center">
          <div className="bold33">
            {stakingPool.data ? (
              <>{formatUnitsToHumanReadable(unstakeInfo.zilAmount, 18)} ZIL</>
            ) : (
              <>
                <div className=" loading-blur">00 ZIL </div>
              </>
            )}
          </div>
          {stakingPool.definition.tokenSymbol &&
            unstakeInfo.zilAmount &&
            stakingPool.definition.poolType === StakingPoolType.LIQUID && (
              <div
                className={`${stakingPool.definition.tokenSymbol && unstakeInfo.zilAmount ? "max-lg:ml-2.5" : "ml-0"} medium15  lg:ml-2.5 4k:ml-3 max-lg:order-1`}
              >
                {unstakeInfo.zilAmount}
                {stakingPool.definition.poolType === StakingPoolType.LIQUID &&
                  stakingPool.definition.tokenSymbol}
              </div>
            )}
        </div>
      </div>
      <div className="max-lg:gap-2.5 max-lg:flex max-lg:justify-center lg:w-1/3 lg:max-w-[250px] w-full pr-3 lg:pb-0 pb-6 lg:pr-9 4k:pr-12">
        <div className="max-lg:w-1/2">
          <Button
            className={` 
              ${stakingPool.definition.poolType === StakingPoolType.LIQUID ? " liquid-hover" : " non-liquid-hover"} btn-primary-grey 4k:py-6 lg:py-5 py-4`}
            disabled={!available}
            onClick={(e) => {
              e.stopPropagation()
              claimUnstake(unstakeInfo.address)
              setViewClaim(false)
            }}
            loading={isInProgress && available}
          >
            {available
              ? preparingClaimUnstakeTx && isCurrentWalletOperationAboutThisPool
                ? "Confirm in wallet"
                : isInProgress
                  ? "Processing"
                  : "Claim"
              : getHumanFormDuration(unstakeInfo.availableAt) + " left"}
          </Button>
        </div>
      </div>
    </div>
  )
}

interface RewardCardProps {
  stakingPool: StakingPool
  rewardInfo: UserNonLiquidStakingPoolRewardData
  selectStakingPoolForView: (stakingPoolId: string | null) => void
  claimReward: (delegatorAddress: string) => void
  stakeReward: (delegatorAddress: string) => void
  setViewClaim: Dispatch<SetStateAction<boolean>>
}

const RewardCard: React.FC<RewardCardProps> = ({
  rewardInfo,
  stakingPool,
  selectStakingPoolForView,
  claimReward,
  stakeReward,
  setViewClaim,
}) => {
  const {
    isStakingRewardInProgress,
    preparingStakeRewardTx,
    isClaimingRewardInProgress,
    preparingClaimRewardTx,
    stakingPoolIdForInProgressOperation,
  } = StakingOperations.useContainer()

  const isCurrentWalletOperationAboutThisPool =
    stakingPoolIdForInProgressOperation === stakingPool.definition.id

  const isClaimRewardInProgress =
    isClaimingRewardInProgress && isCurrentWalletOperationAboutThisPool
  const isStakeRewardInProgress =
    isStakingRewardInProgress && isCurrentWalletOperationAboutThisPool

  return (
    <div
      className={` ${stakingPool.definition.poolType != StakingPoolType.LIQUID ? "purple-border-bottom" : "teal-border-bottom"}  flex gap-2.5 4k:gap-4 lg:w-full max-lg:flex-col bg-aqua-gradient rounded-[20px] items-center cursor-pointer lg:justify-between`}
      onClick={() => {
        selectStakingPoolForView(stakingPool.definition.id)
        setViewClaim(true)
      }}
    >
      <div className="flex lg:flex-col  content-center max-lg:px-3 py-6 4k:py-7 lg:pl-9 4k:pl-12 rounded-lg justify-between max-lg:items-center lg:w-2/3 w-full">
        <div className="flex items-center gap-2 4k:gap-2.5">
          <Image
            className="rounded"
            src={stakingPool.definition.iconUrl}
            alt={`${stakingPool.definition.name} icon`}
            width={31}
            height={31}
          />
          <div className="semi24">{stakingPool.definition.name}</div>
          <div className="text-gray3 lg:hidden text-xl">|</div>
          {stakingPool.definition.poolType != StakingPoolType.LIQUID && (
            <div className="bg-gray3 text-white1 py-1 4k:py-1.5 px-2 4k:px-2.5 items-center gap-2 4k:gap-2.5 medium12 flex ">
              <Image
                className="rounded"
                src={rewards}
                alt="rewards"
                width={14}
                height={15}
              />
              Rewards
            </div>
          )}
        </div>
        <div className="flex lg:mt-3  items-center ">
          <div className="bold33">
            {stakingPool.data ? (
              <>
                {formatUnitsToHumanReadable(rewardInfo.zilRewardAmount, 18)} ZIL
              </>
            ) : (
              <>
                <div className="loading-blur">00 ZIL</div>
              </>
            )}
          </div>
          {rewardInfo.zilRewardAmount &&
            stakingPool.definition.poolType === StakingPoolType.LIQUID && (
              <div
                className={`${rewardInfo.zilRewardAmount && "max-lg:ml-2.5"} medium15  lg:ml-2.5 4k:ml-3 max-lg:order-1`}
              >
                {rewardInfo.zilRewardAmount}
              </div>
            )}
        </div>
      </div>
      <div className="max-lg:gap-2.5 max-lg:flex lg:w-1/3 w-full lg:max-w-[250px] lg:pb-0 pb-6 lg:pr-9 4k:pr-12 max-lg:px-3">
        <div className="max-lg:w-1/2">
          {stakingPool.definition.minimumStake > rewardInfo.zilRewardAmount ? (
            <Tooltip
              placement="top"
              arrow={true}
              overlayClassName="custom-tooltip"
              title={`Reward is less than the minimal staking amount of ${formatUnitsToHumanReadable(
                stakingPool.definition.minimumStake,
                18
              )} ZIL`}
            >
              <Button
                className={`
                ${
                  isStakingRewardInProgress
                    ? stakingPool.definition.poolType === StakingPoolType.LIQUID
                      ? "liquid-loading"
                      : "non-liquid-loading"
                    : ""
                }
                ${stakingPool.definition.poolType === StakingPoolType.LIQUID ? " liquid-hover" : " non-liquid-hover"} btn-primary-grey 4k:py-6 lg:py-5 py-4`}
                onClick={(e) => {
                  e.stopPropagation()
                  stakeReward(rewardInfo.address)
                  setViewClaim(false)
                }}
                loading={isStakingRewardInProgress}
                disabled={true}
              >
                Stake Reward
              </Button>
            </Tooltip>
          ) : (
            <Button
              className={` 
                ${
                  isStakeRewardInProgress
                    ? stakingPool.definition.poolType === StakingPoolType.LIQUID
                      ? "liquid-loading"
                      : "non-liquid-loading"
                    : ""
                }
                ${stakingPool.definition.poolType === StakingPoolType.LIQUID ? " liquid-hover" : " non-liquid-hover"} btn-primary-grey 4k:py-6 lg:py-5 py-4`}
              onClick={(e) => {
                e.stopPropagation()
                stakeReward(rewardInfo.address)
                setViewClaim(false)
              }}
              loading={isStakeRewardInProgress}
            >
              {preparingStakeRewardTx
                ? "Confirm in wallet"
                : isStakeRewardInProgress
                  ? "Processing"
                  : "Stake Reward"}
            </Button>
          )}
        </div>
        <div className="max-lg:w-1/2 lg:mt-2.5">
          <Button
            className={`
               ${
                 isClaimRewardInProgress
                   ? stakingPool.definition.poolType === StakingPoolType.LIQUID
                     ? "liquid-loading"
                     : "non-liquid-loading"
                   : ""
               }
               ${stakingPool.definition.poolType === StakingPoolType.LIQUID ? "liquid-hover" : " non-liquid-hover"} 
               ${stakingPool.definition.minimumStake > rewardInfo.zilRewardAmount ? "btn-primary-grey " : "btn-secondary-grey "}
               4k:py-6 lg:py-5 py-4`}
            onClick={(e) => {
              e.stopPropagation()
              claimReward(rewardInfo.address)
              setViewClaim(false)
            }}
            loading={isClaimRewardInProgress}
          >
            {preparingClaimRewardTx
              ? "Confirm in wallet"
              : isClaimRewardInProgress
                ? "Processing"
                : "Claim Reward"}
          </Button>
        </div>
      </div>
    </div>
  )
}

interface WithdrawZilViewProps {
  setViewClaim: Dispatch<SetStateAction<boolean>>
}

const WithdrawZilView: React.FC<WithdrawZilViewProps> = ({ setViewClaim }) => {
  const {
    availableForUnstaking,
    pendingUnstaking,
    selectStakingPoolForView,
    isUnstakingDataLoading,
    nonLiquidRewards,
  } = StakingPoolsStorage.useContainer()

  const { claimUnstake, claimReward, stakeReward } =
    StakingOperations.useContainer()

  const anyItemsAvailable =
    availableForUnstaking.length > 0 ||
    pendingUnstaking.length > 0 ||
    nonLiquidRewards.length > 0
  const [selectedPoolType, setSelectedPoolType] = useState("ALL")

  const filters = [
    {
      name: "All ",
      type: "ALL",
      activeGradient: "bg-aqua-blue",
    },
    {
      name: "Liquid",
      type: StakingPoolType.LIQUID,
      activeGradient: "bg-tealPrimary",
    },
    {
      name: "Non-liquid",
      type: StakingPoolType.NORMAL,
      activeGradient: "bg-purplePrimary",
    },
  ]
  const filterByPoolType = (item: any) => {
    if (selectedPoolType === "ALL") {
      return true
    }
    return item.stakingPool.definition.poolType === selectedPoolType
  }

  const hasLiquid =
    availableForUnstaking.some(
      (item) => item.stakingPool.definition.poolType === StakingPoolType.LIQUID
    ) ||
    pendingUnstaking.some(
      (item) => item.stakingPool.definition.poolType === StakingPoolType.LIQUID
    ) ||
    nonLiquidRewards.some(
      (item) => item.stakingPool.definition.poolType === StakingPoolType.LIQUID
    )

  const hasNormal =
    availableForUnstaking.some(
      (item) => item.stakingPool.definition.poolType === StakingPoolType.NORMAL
    ) ||
    pendingUnstaking.some(
      (item) => item.stakingPool.definition.poolType === StakingPoolType.NORMAL
    ) ||
    nonLiquidRewards.some(
      (item) => item.stakingPool.definition.poolType === StakingPoolType.NORMAL
    )

  return (
    <div className="relative flex flex-col gap-2 4k:gap-2.5 h-full max-lg:pb-10">
      <div className=" text-center mx-4 p-4">
        {anyItemsAvailable ? (
          <>
            <h1 className="bold33 text-white">Your Claims</h1>
            <p className="mt-2 body2-v2">
              Here is a list of your current <br /> and upcoming claims.
            </p>
          </>
        ) : (
          <h1 className="bold33 text-white">
            <span className="hidden lg:block lg:mt-20 4k:mt-56">
              Stake ZIL. <br /> Earn Rewards.
              <br /> Secure the Network.
            </span>
            <span className="block lg:hidden">Your Claims</span>
          </h1>
        )}
      </div>
      {anyItemsAvailable && hasLiquid && hasNormal && (
        <div className="flex justify-center items-center gap-x-2.5 mt-3 4k:mt-6 mb-2.5 4k:mb-5 max-h-[5vh] mx-3 lg:mx-2 xl:mx-5 4k:mx-6 px-4">
          <div className="text-sm text-gray2">Filter by</div>
          {filters.map((filter, index) => (
            <FilterBtn
              key={index}
              variable={filter.name}
              isActive={selectedPoolType === filter.type}
              onClick={() => setSelectedPoolType(filter.type)}
              activeGradient={filter.activeGradient}
            />
          ))}
        </div>
      )}

      {anyItemsAvailable ? (
        <FastFadeScroll
          isPoolLiquid={StakingPoolType.LIQUID}
          className=" flex-1 overflow-y-scroll  pb-6 mb-16 lg:mb-0 px-2 mx-2 4k:mr-7 lg:mr-5 4k:pr-7 lg:pr-5"
        >
          <div className="grid grid-cols-1 gap-4 lg:gap-5 4k:gap-6 lg:pb-10 ">
            {availableForUnstaking
              .filter(filterByPoolType)
              .map((unstakeClaim, claimIdx) => (
                <UnstakeCard
                  key={claimIdx}
                  available={true}
                  stakingPool={unstakeClaim.stakingPool}
                  unstakeInfo={unstakeClaim.unstakeInfo}
                  claimUnstake={claimUnstake}
                  selectStakingPoolForView={selectStakingPoolForView}
                  setViewClaim={setViewClaim}
                />
              ))}

            {nonLiquidRewards
              .filter(filterByPoolType)
              .map((reward, rewardIdx) => (
                <RewardCard
                  key={rewardIdx}
                  rewardInfo={reward.rewardInfo}
                  stakingPool={reward.stakingPool}
                  selectStakingPoolForView={selectStakingPoolForView}
                  claimReward={claimReward}
                  stakeReward={stakeReward}
                  setViewClaim={setViewClaim}
                />
              ))}

            {pendingUnstaking
              .filter(filterByPoolType)
              .map((pendingUnstakeClaim, claimIdx) => (
                <UnstakeCard
                  key={claimIdx + 1000}
                  available={false}
                  stakingPool={pendingUnstakeClaim.stakingPool}
                  unstakeInfo={pendingUnstakeClaim.unstakeInfo}
                  claimUnstake={claimUnstake}
                  selectStakingPoolForView={selectStakingPoolForView}
                  setViewClaim={setViewClaim}
                />
              ))}
          </div>
        </FastFadeScroll>
      ) : (
        !isUnstakingDataLoading && (
          <div className="text-center text-white mx-auto">
            <div className="mb-8 body2-v2">
              Seems like you have nothing to claim yet. <br />
              Start staking and give us your thoughts !
            </div>
            <Button
              type="primary"
              className="btn-primary-teal-lg !w-fit px-11 4k:px-12 group mt-8"
              onClick={() => showNewMessage("")}
            >
              Leave Feedback
            </Button>
          </div>
        )
      )}
    </div>
  )
}

export default WithdrawZilView

```

`src/components/zilGiveaway.tsx`:

```tsx
import { AppConfigStorage } from "@/contexts/appConfigStorage"
import { WalletConnector } from "@/contexts/walletConnector"
import {
  CHAIN_ZQ2_DEVNET,
  CHAIN_ZQ2_PROTOMAINNET,
  CHAIN_ZQ2_PROTOTESTNET,
} from "@/misc/chainConfig"
import { Button, Modal } from "antd"
import { useState } from "react"

const ZilGiveaway: React.FC = () => {
  const [showRequestZilPopup, setShowRequestZilPopup] = useState(false)
  const [zilRequested, setZilRequested] = useState(false)
  const [zilRequestFailed, setZilRequestFailed] = useState(false)
  const [failureReason, setFailureReason] = useState("")
  const { walletAddress } = WalletConnector.useContainer()
  const { appConfig } = AppConfigStorage.useContainer()

  const { updateWalletBalance } = WalletConnector.useContainer()

  const requestZil = async () => {
    const url =
      appConfig.chainId === CHAIN_ZQ2_DEVNET.id
        ? "https://faucet.zq2-devnet.zilliqa.com"
        : CHAIN_ZQ2_PROTOTESTNET.id === appConfig.chainId
          ? "https://faucet.zq2-prototestnet.zilliqa.com"
          : CHAIN_ZQ2_PROTOMAINNET.id === appConfig.chainId
            ? "https://faucet.zq2-protomainnet.zilliqa.com"
            : "N/A"

    // const formData = new FormData()
    // formData.append("address", walletAddress!.toLowerCase())
    const params = new URLSearchParams()
    params.append("address", walletAddress!)

    try {
      await fetch(url, {
        method: "POST",
        body: params,
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
      })

      setZilRequested(true)
    } catch (error: any) {
      const errorString = `${error}`.trim()
      if (errorString.startsWith("TypeError: Failed to fetch")) {
        // This is hack around not adding the correct CORS headers on the faucet side
        setZilRequested(true)
      } else {
        setFailureReason(error.message)
        setZilRequestFailed(true)
      }
    } finally {
      setTimeout(() => {
        updateWalletBalance()
      }, 5000)
    }
  }

  const closePopup = () => {
    setShowRequestZilPopup(false)
    setZilRequested(false)
    setZilRequestFailed(false)
  }

  return (
    <>
      <Button
        size="small"
        className="btn-primary-teal px-2 md:px-3 max-lg:min-h-[39px] "
        onClick={() => {
          setShowRequestZilPopup(true)
          requestZil()
        }}
      >
        + ZIL
      </Button>

      <Modal
        title={`Requesting ZIL for ${walletAddress}`}
        open={showRequestZilPopup}
        onOk={() => setShowRequestZilPopup(false)}
        onCancel={() => setShowRequestZilPopup(false)}
        cancelButtonProps={{ className: "hidden" }}
        okButtonProps={{ className: "hidden" }}
        maskClosable={false}
      >
        <div className="pt-5">
          {zilRequestFailed ? (
            <>
              <div>Request failed</div>
              <div>{failureReason}</div>
              <div className="flex justify-end">
                <Button className="btn-primary-cyan " onClick={closePopup}>
                  Ok
                </Button>
              </div>
            </>
          ) : zilRequested ? (
            <div>
              <div>Free ZIL should be in your wallet soon!</div>
              <div>
                Remember that you can only make one request every 1 minute
              </div>
              <div className="flex justify-end">
                <Button
                  className="btn-primary-teal-lg mt-5"
                  onClick={closePopup}
                >
                  Ok
                </Button>
              </div>
            </div>
          ) : (
            <div className="loading-blur"> Loading...</div>
          )}
        </div>
      </Modal>
    </>
  )
}

export default ZilGiveaway

```

`src/contexts/appConfigStorage.tsx`:

```tsx
"use client"

import { AppConfig } from "@/pages/api/config"
import { createContainer } from "./context"

const useAppConfigStorage = (initialState?: { appConfig: AppConfig }) => {
  return {
    appConfig: initialState!.appConfig,
  }
}

export const AppConfigStorage = createContainer(useAppConfigStorage)

```

`src/contexts/context.tsx`:

```tsx
"use client"
/**
 * This file is a copy of https://github.com/jamiebuilds/unstated-next/blob/master/src/unstated-next.tsx
 * The reason it is the copy is that the project is no longer maintained and we are using new version of React
 *
 * In theory, this should land in the "@zilliqa/zilliqa-ui" but then you need to set up jsx transpilation
 * if you are reading that and have time to do it, please do!
 */
import React from "react"

const EMPTY: unique symbol = Symbol()

export interface ContainerProviderProps<State> {
  initialState?: State
  children: React.ReactNode
}

export interface Container<Value, State> {
  Provider: React.ComponentType<ContainerProviderProps<State>>
  useContainer: () => Value
  MockProvider: React.ComponentType<ContainerProviderProps<Partial<Value>>>
}

export function createContainer<Value, State>(
  useHook: (initialState?: State) => Value,
  mockkContextCreator?: (overrides: Partial<Value>) => Value
): Container<Value, State> {
  let Context = React.createContext<Value | typeof EMPTY>(EMPTY)

  function Provider(props: ContainerProviderProps<State>) {
    let value = useHook(props.initialState)
    return <Context.Provider value={value}>{props.children}</Context.Provider>
  }

  function MockProvider(props: ContainerProviderProps<Partial<Value>>) {
    if (!mockkContextCreator) {
      throw new Error(
        "MockProvider can only be used when mockkContextCreator is provided"
      )
    }
    let value = mockkContextCreator(props.initialState || {})
    return <Context.Provider value={value}>{props.children}</Context.Provider>
  }

  function useContainer(): Value {
    let value = React.useContext(Context)
    if (value === EMPTY) {
      throw new Error("Component must be wrapped with <Container.Provider>")
    }
    return value
  }

  return { Provider, useContainer, MockProvider }
}

```

`src/contexts/dummyConnector.tsx`:

```tsx
import { Connector } from 'wagmi'
import { DummyWallet } from '@/misc/walletsConfig'
import { createPublicClient, custom } from 'viem'

export class DummyConnector {
  id = 'dummy'
  name = 'Dummy Wallet'
  ready = true
  wallet: DummyWallet

  constructor({ chains, options }: { chains: any[]; options: { wallet: DummyWallet } }) {
    super({ chains, options })
    this.wallet = options.wallet
  }

  async connect() {
    return {
      account: this.wallet.address,
      chain: { id: this.chains[0].id, unsupported: false },
    }
  }

  async disconnect() {}

  async getAccount() {
    return this.wallet.address
  }

  async getChainId() {
    return this.chains[0].id
  }

  async getProvider() {
    return createPublicClient({
      chain: this.chains[0],
      transport: custom({
        request: async ({ method, params }) => {
          if (method === 'eth_getBalance' && params[0] === this.wallet.address) {
            return BigInt(this.wallet.currentZil).toString()
          }
          if (method === 'eth_requestAccounts' || method === 'eth_accounts') {
            return [this.wallet.address]
          }
          throw new Error(`Метод ${method} не реализован`)
        },
      }),
    })
  }

  async getSigner() {
    return null
  }

  async isAuthorized() {
    return true
  }
}

```

`src/contexts/stakingOperations.tsx`:

```tsx
import { notification } from "antd"
import { useEffect, useState } from "react"
import { useWaitForTransactionReceipt, useWriteContract } from "wagmi"
import { createContainer } from "./context"
import { WalletConnector } from "./walletConnector"
import { StakingPoolsStorage } from "./stakingPoolsStorage"
import { Address, formatUnits, WriteContractParameters } from "viem"
import { baseDelegatorAbi, nonLiquidDelegatorAbi } from "@/misc/stakingAbis"
import { useConfig } from "wagmi"
import { useGasPrice } from "wagmi"
import { DateTime } from "luxon"
import { getHumanFormDuration } from "@/misc/formatting"

const useTxOperation = (
  isDummyWalletConnected: boolean,
  setDummyWalletPopupContent: ({
    content,
    onOk,
    onCancel,
  }: {
    content: string
    onOk: () => void
    onCancel: () => void
  }) => void,
  setIsDummyWalletPopupOpen: (isOpen: boolean) => void,
  reloadAppUserData: () => void,
  successMessage: string,
  successDescription: string,
  errorMessage: string,
  errorDescription: string
) => {
  const [txHash, setTxHash] = useState<Address | undefined>(undefined)

  const [isTxInPreparation, setIsTxInPreparation] = useState(false)

  const [dummyTxSuccess, setDummyTxSuccess] = useState(false)
  const [dummyTxError, setDummyTxError] = useState(false)

  const {
    isLoading: isTxProcessedByChain,
    error: txContractError,
    status: txReceiptStatus,
  } = useWaitForTransactionReceipt({
    hash: txHash,
  })

  const {
    writeContract,
    status: txSubmissionStatus,
    error: txSubmissionError,
    data: currentTxData,
  } = useWriteContract()

  const onDummyWalletOperationPopupOk = () => {
    setDummyTxSuccess(true)
    setIsDummyWalletPopupOpen(false)
    setIsTxInPreparation(false)
    reloadAppUserData()
  }

  const onDummyWalletOperationPopupCancel = () => {
    setDummyTxError(true)
    setIsDummyWalletPopupOpen(false)
    setIsTxInPreparation(false)
    reloadAppUserData()
  }

  const callContract = (txCallParams: WriteContractParameters) => {
    setIsTxInPreparation(true)
    setDummyTxSuccess(false)
    setDummyTxError(false)
    setTxHash(undefined)

    if (isDummyWalletConnected) {
      setDummyWalletPopupContent({
        content: `Now User gonna approve the wallet transaction, and then shown notification with ${successMessage}`,
        onOk: onDummyWalletOperationPopupOk,
        onCancel: onDummyWalletOperationPopupCancel,
      })
      setIsDummyWalletPopupOpen(true)
      setTxHash("0x1234567890234567890234567890234567890" as Address)
    } else {
      try {
        writeContract(txCallParams)
      } catch (error) {
        notification.error({
          message: errorMessage,
          description:
            errorDescription + "\nError while submitting transaction to chain",
          placement: "topRight",
        })
        console.error(error)
      } finally {
        setIsTxInPreparation(false)
      }
    }
  }

  useEffect(() => {
    if (txReceiptStatus === "success" || dummyTxSuccess) {
      notification.success({
        message: successMessage,
        description: successDescription,
        placement: "topRight",
      })
      reloadAppUserData()
    }
  }, [txReceiptStatus, dummyTxSuccess])

  useEffect(() => {
    if (txSubmissionStatus === "success") {
      setTxHash(currentTxData)
    }
  }, [txSubmissionStatus, currentTxData])

  useEffect(() => {
    if (txSubmissionStatus === "error" || dummyTxError) {
      notification.error({
        message: errorMessage,
        description:
          errorDescription + "\nError while submitting transaction to chain",
        placement: "topRight",
      })

      console.error({ txSubmissionStatus, txSubmissionError })
    }
  }, [txSubmissionStatus, dummyTxError])

  useEffect(() => {
    if (txReceiptStatus === "error") {
      notification.error({
        message: errorMessage,
        description:
          errorMessage + "\nError while processing transaction on chain",
        placement: "topRight",
      })

      console.error({ txReceiptStatus, txContractError })
    }
  }, [txReceiptStatus, txSubmissionStatus])

  const clearState = () => {
    setTxHash(undefined)
  }

  return {
    isTxInPreparation: isTxInPreparation || txSubmissionStatus === "pending",
    isTxProcessedByChain: isTxProcessedByChain && !isDummyWalletConnected,
    txHash,
    txContractError,
    callContract,
    clearState,
  }
}

const useStakingOperations = () => {
  const { isDummyWalletConnected, updateWalletBalance, walletAddress } =
    WalletConnector.useContainer()

  const {
    reloadUserStakingPoolsData,
    stakingPoolForView,
    availableStakingPools,
  } = StakingPoolsStorage.useContainer()

  const wagmiConfig = useConfig()

  const [isDummyWalletPopupOpen, setIsDummyWalletPopupOpen] = useState(false)
  const [dummyWalletPopupContent, setDummyWalletPopupContent] = useState<{
    content: string
    onOk: () => void
    onCancel: () => void
  } | null>(null)

  const [
    stakingPoolIdForInProgressOperation,
    setStakingPoolIdForInProgressOperation,
  ] = useState<string | null>(null)

  const stakingPoolId = stakingPoolForView?.stakingPool.definition.id

  const { data: reportedGasPrice } = useGasPrice()

  // eth_gasPrice returned by our chain is consistently lower than the actual gas price
  // so we multiply it by 125% to get a more accurate estimate
  const uppedGasPrice = ((reportedGasPrice || 0n) * 125n) / 100n

  const getGasCostInZil = (estimatedGas: bigint) => {
    return Math.ceil(parseFloat(formatUnits(estimatedGas * uppedGasPrice, 18)))
  }

  const setStakingPoolIdForInProgressOperationByAddress = (address: string) => {
    const pool = availableStakingPools.find(
      (pool) => pool.definition.address === address
    )
    setStakingPoolIdForInProgressOperation(pool?.definition.id || null)
  }

  /**
   * STAKING
   */

  const stakingCallEstimatedGas = 0x1e8480n
  const {
    isTxInPreparation: preparingStakingTx,
    isTxProcessedByChain: submittingStakingTx,
    txHash: stakingCallTxHash,
    callContract: callContractStakeRaw,
    clearState: clearStakingState,
    txContractError: stakeContractCallError,
  } = useTxOperation(
    isDummyWalletConnected,
    setDummyWalletPopupContent,
    setIsDummyWalletPopupOpen,
    () => {
      reloadUserStakingPoolsData()
      updateWalletBalance()
    },
    "✅\u00A0 Staking successful",
    "You have successfully staked ZIL",
    "❌\u00A0 Staking failed",
    "Please try again later or contact support."
  )

  const stake = (delegatorAddress: string, weiToStake: bigint) => {
    setStakingPoolIdForInProgressOperationByAddress(delegatorAddress)
    callContractStakeRaw({
      address: delegatorAddress as Address,
      abi: baseDelegatorAbi,
      functionName: "stake",
      args: [],
      value: weiToStake,
      chain: wagmiConfig.chains[0], // we always have only one chain defined
      account: walletAddress as Address,
    })
  }

  /**
   * UNSTAKING
   */

  const unboudingPeriod = stakingPoolForView?.stakingPool.definition
    .withdrawPeriodInMinutes
    ? getHumanFormDuration(
        DateTime.now().plus({
          minutes:
            stakingPoolForView.stakingPool.definition.withdrawPeriodInMinutes,
        })
      )
    : "the unbonding period"

  const unstakingCallEstimatedGas = 0x1e8480n

  const {
    isTxInPreparation: preparingUnstakingTx,
    isTxProcessedByChain: submittingUnstakingTx,
    txHash: unstakingCallTxHash,
    txContractError: unstakeContractCallError,
    callContract: callContractUnstakeRaw,
    clearState: clearUnstakingState,
  } = useTxOperation(
    isDummyWalletConnected,
    setDummyWalletPopupContent,
    setIsDummyWalletPopupOpen,
    () => {
      reloadUserStakingPoolsData()
      updateWalletBalance()
    },
    "✅\u00A0 Unstaking Requested",
    `You ZIL will be ready to claim in ${unboudingPeriod}`,
    "❌\u00A0 Unstaking failed",
    "Please try again later or contact support."
  )

  const unstake = (delegatorAddress: string, tokensToUnstake: bigint) => {
    setStakingPoolIdForInProgressOperationByAddress(delegatorAddress)
    callContractUnstakeRaw({
      address: delegatorAddress as Address,
      abi: baseDelegatorAbi,
      functionName: "unstake",
      args: [tokensToUnstake],
      chain: wagmiConfig.chains[0], // we always have only one chain defined
      account: walletAddress as Address,
    })
  }

  /**
   * CLAIMING UNSTAKE
   */

  const claimUnstakingCallEstimatedGas = 0x1e8480n

  const {
    isTxInPreparation: preparingClaimUnstakeTx,
    isTxProcessedByChain: submittingClaimUnstakeTx,
    txHash: claimUnstakeCallTxHash,
    txContractError: claimContractCallError,
    callContract: callContractClaimUnstakeRaw,
    clearState: clearClaimUnstakeState,
  } = useTxOperation(
    isDummyWalletConnected,
    setDummyWalletPopupContent,
    setIsDummyWalletPopupOpen,
    () => {
      reloadUserStakingPoolsData()
      updateWalletBalance()
    },
    "🎉\u00A0 Claiming successful",
    "You have successfully claimed your ZIL withdrawals.",
    "❌\u00A0 Claiming failed",
    "There was an error while claiming your ZIL withdrawals."
  )

  const claimUnstake = (delegatorAddress: string) => {
    setStakingPoolIdForInProgressOperationByAddress(delegatorAddress)
    callContractClaimUnstakeRaw({
      address: delegatorAddress as Address,
      abi: baseDelegatorAbi,
      functionName: "claim",
      args: [],
      chain: wagmiConfig.chains[0], // we always have only one chain defined
      account: walletAddress as Address,
    })
  }

  /**
   * CLAIM REWARDS
   */

  const claimRewardCallEstimatedGas = 0x1e8480n

  const {
    isTxInPreparation: preparingClaimRewardTx,
    isTxProcessedByChain: submittingClaimRewardTx,
    txHash: claimRewardCallTxHash,
    txContractError: claimRewardContractCallError,
    callContract: callContractClaimRewardRaw,
    clearState: clearClaimRewardState,
  } = useTxOperation(
    isDummyWalletConnected,
    setDummyWalletPopupContent,
    setIsDummyWalletPopupOpen,
    () => {
      reloadUserStakingPoolsData()
      updateWalletBalance()
    },
    "🎉\u00A0 Claiming rewards successful",
    "You have successfully claimed your ZIL rewards.",
    "❌\u00A0 Claiming rewards failed",
    "There was an error while claiming your ZIL rewards."
  )

  const claimReward = (delegatorAddress: string) => {
    setStakingPoolIdForInProgressOperationByAddress(delegatorAddress)
    callContractClaimRewardRaw({
      address: delegatorAddress as Address,
      abi: nonLiquidDelegatorAbi,
      functionName: "withdrawAllRewards",
      args: [],
      chain: wagmiConfig.chains[0], // we always have only one chain defined
      account: walletAddress as Address,
    })
  }

  /**
   * RESTAKE REWARDS
   */

  const stakeRewardCallEstimatedGas = 0x1e8480n

  const {
    isTxInPreparation: preparingStakeRewardTx,
    isTxProcessedByChain: submittingStakeRewardTx,
    txHash: stakeRewardCallTxHash,
    txContractError: stakeRewardContractCallError,
    callContract: callContractStakeRewardRaw,
    clearState: clearStakeRewardState,
  } = useTxOperation(
    isDummyWalletConnected,
    setDummyWalletPopupContent,
    setIsDummyWalletPopupOpen,
    () => {
      reloadUserStakingPoolsData()
      updateWalletBalance()
    },
    "✅\u00A0 Staking rewards successful",
    "You have successfully staked rewards",
    "❌\u00A0 Staking rewards failed",
    "There was an error while staking rewards"
  )

  const stakeReward = (delegatorAddress: string) => {
    setStakingPoolIdForInProgressOperationByAddress(delegatorAddress)
    callContractStakeRewardRaw({
      address: delegatorAddress as Address,
      abi: nonLiquidDelegatorAbi,
      functionName: "stakeRewards",
      args: [],
      chain: wagmiConfig.chains[0], // we always have only one chain defined
      account: walletAddress as Address,
    })
  }

  /**
   * OTHER
   */

  useEffect(
    function clearStateOnDelegatorChange() {
      clearStakingState()
      clearUnstakingState()
      clearClaimUnstakeState()
      clearClaimRewardState()
      clearStakeRewardState()
    },
    [stakingPoolId]
  )

  const isStakingInProgress = submittingStakingTx || preparingStakingTx
  const isUnstakingInProgress = submittingUnstakingTx || preparingUnstakingTx
  const isClaimingUnstakeInProgress =
    submittingClaimUnstakeTx || preparingClaimUnstakeTx
  const isClaimingRewardInProgress =
    submittingClaimRewardTx || preparingClaimRewardTx
  const isStakingRewardInProgress =
    submittingStakeRewardTx || preparingStakeRewardTx

  const isAnyWalletOperationInProgress =
    isStakingInProgress ||
    isUnstakingInProgress ||
    isClaimingUnstakeInProgress ||
    isClaimingRewardInProgress ||
    isStakingRewardInProgress

  return {
    isDummyWalletPopupOpen,
    dummyWalletPopupContent,
    setIsDummyWalletPopupOpen,

    isAnyWalletOperationInProgress,
    stakingPoolIdForInProgressOperation,

    stake,
    preparingStakingTx,
    isStakingInProgress,
    stakingCallTxHash,
    stakeContractCallError,
    stakingCallZilFees: getGasCostInZil(stakingCallEstimatedGas),

    unstake,
    preparingUnstakingTx,
    isUnstakingInProgress,
    unstakingCallTxHash,
    unstakeContractCallError,
    unstakingCallZilFees: getGasCostInZil(unstakingCallEstimatedGas),

    claimUnstake,
    preparingClaimUnstakeTx,
    isClaimingUnstakeInProgress,
    claimUnstakeCallTxHash,
    claimContractCallError,
    claimUnstakeCallZilFees: getGasCostInZil(claimUnstakingCallEstimatedGas),

    claimReward,
    preparingClaimRewardTx,
    isClaimingRewardInProgress,
    claimRewardCallTxHash,
    claimRewardContractCallError,
    claimRewardCallZilFees: getGasCostInZil(claimRewardCallEstimatedGas),

    stakeReward,
    preparingStakeRewardTx,
    isStakingRewardInProgress,
    stakeRewardCallTxHash,
    stakeRewardContractCallError,
    stakeRewardCallZilFees: getGasCostInZil(stakeRewardCallEstimatedGas),
  }
}

export const StakingOperations = createContainer(useStakingOperations)

```

`src/contexts/stakingPoolsStorage.tsx`:

```tsx
"use client"

import { useEffect, useMemo, useState } from "react"
import { createContainer } from "./context"
import { WalletConnector } from "./walletConnector"
import { DateTime } from "luxon"
import {
  StakingPool,
  stakingPoolsConfigForChainId,
} from "@/misc/stakingPoolsConfig"
import {
  getWalletNonLiquidStakingPoolRewardData,
  getWalletStakingData,
  getWalletUnstakingData,
  UserNonLiquidStakingPoolRewardData,
  UserStakingPoolData,
  UserUnstakingPoolData,
} from "@/misc/walletsConfig"
import { AppConfigStorage } from "./appConfigStorage"
import { useRouter } from "next/router"

// all available withdraws for one delegator are withdrawn using single tx, so we aggregate them to shoow only one UI entry
function mergeAvailableWithdrawUnstakeRequests(
  data: {
    unstakeInfo: UserUnstakingPoolData
    stakingPool: StakingPool
  }[]
) {
  return data
    .reduce(
      (acc, unstakeData) => {
        // if not availble then we want to have a separate entry for it
        if (unstakeData.unstakeInfo.availableAt > DateTime.now()) {
          acc.push(unstakeData)
          return acc
        }

        const existingIdx = acc.findIndex(
          (entry) =>
            entry.stakingPool.definition.id ===
            unstakeData.stakingPool.definition.id
        )

        if (existingIdx !== -1) {
          // if we already have an available entry for this pool, we want to aggregate the zilAmount
          acc[existingIdx] = {
            stakingPool: unstakeData.stakingPool,
            unstakeInfo: {
              availableAt: unstakeData.unstakeInfo.availableAt,
              address: unstakeData.unstakeInfo.address,
              zilAmount:
                unstakeData.unstakeInfo.zilAmount +
                acc[existingIdx].unstakeInfo.zilAmount,
            },
          }
        } else {
          // if we don't yet have an available entry for this pool, we want to add it
          acc.push(unstakeData)
        }

        return acc
      },
      new Array<{
        unstakeInfo: UserUnstakingPoolData
        stakingPool: StakingPool
      }>()
    )
    .toSorted(
      (claimA, claimB) =>
        claimA.unstakeInfo.availableAt.diff(claimB.unstakeInfo.availableAt)
          .milliseconds
    )
}

const useStakingPoolsStorage = () => {
  const router = useRouter()

  const { walletAddress } = WalletConnector.useContainer()

  const { appConfig } = AppConfigStorage.useContainer()

  const [availableStakingPoolsData, setAvailableStakingPoolsData] = useState<
    StakingPool[]
  >([])

  const [userStakingPoolsData, setUserStakingPoolsData] = useState<
    UserStakingPoolData[]
  >([])
  const [userUnstakesData, setUserUnstakesData] = useState<
    UserUnstakingPoolData[]
  >([])
  const [userNonLiquidPoolRewards, setUserNonLiquidPoolRewards] = useState<
    UserNonLiquidStakingPoolRewardData[]
  >([])

  const [stakingPoolForView, setSelectedStakingPool] =
    useState<StakingPool | null>(null)

  const [isUnstakingDataLoading, setIsUnstakingDataLoading] = useState(false)

  /**
   * This interval forces rerender and state recalculation for subset of items
   * that have availableAt property. This is done by simply copying such state.
   * This methid is cheap and does not require any additional API calls.
   * This makes the frontend to properly display the time left and availability
   * for such items
   */
  const _refreshItemsWithAvailableAt = useMemo(
    () =>
      setInterval(() => {
        console.log("Refreshing unstakings")
        setUserUnstakesData((current) => [...current])
        setUserNonLiquidPoolRewards((current) => [...current])
      }, 5000),
    []
  )

  const reloadUserStakingPoolsData = () => {
    if (!walletAddress) {
      setUserStakingPoolsData([])
      setUserUnstakesData([])
      setUserNonLiquidPoolRewards([])
      return
    }

    getWalletStakingData(walletAddress, appConfig!.chainId)
      .then(setUserStakingPoolsData)
      .catch(console.error)
    setIsUnstakingDataLoading(true)
    getWalletUnstakingData(walletAddress, appConfig!.chainId)
      .then(setUserUnstakesData)
      .catch(console.error)
      .finally(() => setIsUnstakingDataLoading(false))

    getWalletNonLiquidStakingPoolRewardData(walletAddress, appConfig!.chainId)
      .then(setUserNonLiquidPoolRewards)
      .catch(console.error)
      .finally(() => setIsUnstakingDataLoading(false))
  }

  useEffect(
    function triggerUserDataLoadingOnWalletConnect() {
      reloadUserStakingPoolsData()
    },
    [walletAddress]
  )

  useEffect(function populateStakingPoolsDefinitionsAndTriggerDataLoading() {
    const stakingPoolsConfig = stakingPoolsConfigForChainId[appConfig.chainId]

    setAvailableStakingPoolsData(
      stakingPoolsConfig.map((configEntry) => ({
        definition: configEntry.definition,
        data: null,
      }))
    )

    Promise.all(
      stakingPoolsConfig.map(async (config) => {
        const data = await config.delegatorDataProvider(
          config.definition,
          appConfig.chainId
        )

        setAvailableStakingPoolsData((prev) => {
          const updated = prev.map((entry) => {
            if (entry.definition.id === config.definition.id) {
              return {
                ...entry,
                data,
              }
            }

            return entry
          })

          return updated
        })
      })
    )
  }, []) // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(() => {
    const poolToShow = router.query.poolId as string | null

    const selectedPool =
      poolToShow &&
      availableStakingPoolsData.find(
        (pool) => pool.definition.id === poolToShow
      )

    if (selectedPool) {
      setSelectedStakingPool(selectedPool)
    } else {
      setSelectedStakingPool(null)
    }
  }, [router.query.poolId, availableStakingPoolsData])

  useEffect(
    function updateStakingForViewOnStakingPoolsDataChange() {
      if (stakingPoolForView) {
        const updatedStakingPool = availableStakingPoolsData.find(
          (pool) => pool.definition.id === stakingPoolForView.definition.id
        )

        if (updatedStakingPool) {
          setSelectedStakingPool(updatedStakingPool)
        }
      }
    },
    [availableStakingPoolsData]
  )

  const selectStakingPoolForView = (stakingPoolId: string | null) => {
    if (!stakingPoolId || stakingPoolId === stakingPoolForView?.definition.id) {
      const currentQuery = router.query
      delete currentQuery.poolId

      router.push(
        {
          query: currentQuery,
        },
        undefined,
        { shallow: true }
      )

      return
    } else {
      router.push(
        {
          query: { poolId: stakingPoolId },
        },
        undefined,
        { shallow: true }
      )
    }
  }

  const combinedStakingPoolsData = availableStakingPoolsData
    .map((stakingPool) => {
      const userStakingPoolData = userStakingPoolsData.find(
        (userPool) => userPool.address === stakingPool.definition.address
      )

      return {
        stakingPool,
        userData: userStakingPoolData,
      }
    })
    .toSorted((a, b) => {
      const diff =
        (b.userData?.stakingTokenAmount || 0n) -
        (a.userData?.stakingTokenAmount || 0n)

      if (diff === 0n) {
        return a.stakingPool.definition.name.localeCompare(
          b.stakingPool.definition.name
        )
      }

      return diff > 0 ? 1 : -1
    })

  const combinedSelectedStakingPoolForViewData = stakingPoolForView
    ? {
        stakingPool: stakingPoolForView,
        userData: {
          staked: userStakingPoolsData.find(
            (userPoolData) =>
              userPoolData.address === stakingPoolForView.definition.address
          ),
          unstaked: mergeAvailableWithdrawUnstakeRequests(
            userUnstakesData
              .filter(
                (userPoolData) =>
                  userPoolData.address === stakingPoolForView.definition.address
              )
              .map((unstakeInfo) => ({
                unstakeInfo,
                stakingPool: stakingPoolForView,
              }))
          ).map((unstakeData) => unstakeData.unstakeInfo),
          reward: userNonLiquidPoolRewards.find(
            (userPoolData) =>
              userPoolData.address === stakingPoolForView.definition.address
          ),
        },
      }
    : null

  const combinedUserUnstakesData =
    userUnstakesData?.map((unstakeInfo) => ({
      unstakeInfo,
      stakingPool: availableStakingPoolsData.find(
        (pool) => pool.definition.address === unstakeInfo.address
      )!,
    })) || []

  const combinedUserNonLiquidPoolRewards =
    userNonLiquidPoolRewards?.map((rewardInfo) => ({
      rewardInfo,
      stakingPool: availableStakingPoolsData.find(
        (pool) => pool.definition.address === rewardInfo.address
      )!,
    })) || []

  const availableForUnstaking = mergeAvailableWithdrawUnstakeRequests(
    combinedUserUnstakesData.filter(
      (unstakeData) => unstakeData.unstakeInfo.availableAt <= DateTime.now()
    )
  )

  const pendingUnstaking = combinedUserUnstakesData
    .filter(
      (unstakeData) => unstakeData.unstakeInfo.availableAt > DateTime.now()
    )
    .toSorted(
      (claimA, claimB) =>
        claimA.unstakeInfo.availableAt.diff(claimB.unstakeInfo.availableAt)
          .milliseconds
    )

  const getMinimalPoolStakingAmount = (stakinPoolAddress: string) => {
    const stakingPoolData = availableStakingPoolsData.find(
      (pool) => pool.definition.address === stakinPoolAddress
    )

    if (!stakingPoolData) {
      throw new Error("Staking pool not found") // this means that config is invalid
    }

    return stakingPoolData.definition.minimumStake
  }

  return {
    availableStakingPools: availableStakingPoolsData,
    stakingPoolForView: combinedSelectedStakingPoolForViewData,
    selectStakingPoolForView,
    combinedStakingPoolsData,
    availableForUnstaking,
    pendingUnstaking,
    nonLiquidRewards: combinedUserNonLiquidPoolRewards,
    reloadUserStakingPoolsData,
    isUnstakingDataLoading,
    getMinimalPoolStakingAmount,
  }
}

export const StakingPoolsStorage = createContainer(useStakingPoolsStorage)

```

`src/contexts/walletConnector.tsx`:

```tsx
"use client"

import { useState } from "react"
import { createContainer } from "./context"
import { DummyWallet } from "@/misc/walletsConfig"
import { useAccount, useBalance } from "wagmi"
import { Address } from "viem"

export enum ConnectedWalletType {
  None,
  MockWallet,
  RealWallet,
}

const useWalletConnector = () => {
  /**
   * Dummy Wallet section
   */
  const [isDummyWalletConnected, setIsDummyWalletConnected] = useState(false)
  const [isDummyWalletConnecting, setIsDummyWalletConnecting] = useState(false)
  const [isDummyWalletSelectorOpen, setIsDummyWalletSelectorOpen] =
    useState(false)
  const [dummyWallet, setDummyWallet] = useState<DummyWallet | null>(null)

  const connectDummyWallet = () => {
    setIsDummyWalletConnecting(true)
    setIsDummyWalletSelectorOpen(true)
  }

  const selectDummyWallet = (wallet: DummyWallet) => {
    setDummyWallet(wallet)
    setIsDummyWalletConnected(true)
    setIsDummyWalletSelectorOpen(false)
    setIsDummyWalletConnecting(false)
  }

  const disconnectDummyWallet = () => {
    setIsDummyWalletConnected(false)
    setDummyWallet(null)
    setIsDummyWalletConnecting(false)
    setIsDummyWalletSelectorOpen(false)
  }

  /**
   * Rainbow wallet section
   */
  const walletAccount = useAccount()

  /**
   * Wallet data
   */

  const isWalletConnected = walletAccount.isConnected || isDummyWalletConnected
  const connectedWalletType = isDummyWalletConnected
    ? ConnectedWalletType.MockWallet
    : walletAccount.isConnected
      ? ConnectedWalletType.RealWallet
      : ConnectedWalletType.None

  const walletAddress =
    connectedWalletType === ConnectedWalletType.MockWallet
      ? dummyWallet!.address
      : connectedWalletType === ConnectedWalletType.RealWallet
        ? walletAccount.address || null
        : null

  const { data: zilBalanceData, refetch: refetchZilBalance } = useBalance({
    address: walletAddress ? (walletAddress as Address) : undefined,
  })

  let zilAvailable: bigint | null = null

  const updateWalletBalance = () => {
    if (isDummyWalletConnected) {
      return
    }

    refetchZilBalance()
  }

  if (zilBalanceData) {
    zilAvailable = zilBalanceData.value
  } else if (isDummyWalletConnected) {
    zilAvailable = dummyWallet!.currentZil
  }

  return {
    isWalletConnected,
    isDummyWalletConnecting,
    isDummyWalletConnected,
    connectDummyWallet,
    disconnectDummyWallet,
    walletAddress,
    zilAvailable,
    isDummyWalletSelectorOpen,
    selectDummyWallet,
    connectedWalletType,
    updateWalletBalance,
  }
}

export const WalletConnector = createContainer(useWalletConnector)

```

`src/misc/chainConfig.ts`:

```ts
import { connectorsForWallets } from "@rainbow-me/rainbowkit"
import {
  coinbaseWallet,
  ledgerWallet,
  metaMaskWallet,
  phantomWallet,
  rabbyWallet,
  rainbowWallet,
  trustWallet,
  walletConnectWallet,
} from "@rainbow-me/rainbowkit/wallets"
import { createClient, createPublicClient, defineChain, http } from "viem"
import { createConfig } from "wagmi"

export const CHAIN_ZQ2_DEVNET = defineChain({
  id: 33469,
  name: "Zq2 Devnet",
  nativeCurrency: { name: "ZIL", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zq2-devnet.zilliqa.com"],
    },
  },
  blockExplorers: {
    default: {
      name: "Otterscan",
      url: "https://explorer.zq2-devnet.zilliqa.com",
    },
  },
})

export const CHAIN_ZQ2_PROTOTESTNET = defineChain({
  id: 33103,
  name: "Zq2 ProtoTestnet",
  nativeCurrency: { name: "ZIL", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zq2-prototestnet.zilliqa.com"],
    },
  },
  blockExplorers: {
    default: {
      name: "Otterscan",
      url: "https://explorer.zq2-prototestnet.zilliqa.com",
    },
  },
})

export const CHAIN_ZQ2_PROTOMAINNET = defineChain({
  id: 32770,
  name: "Zq2 ProtoMainnet",
  nativeCurrency: { name: "ZIL", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zq2-protomainnet.zilliqa.com"],
    },
  },
  blockExplorers: {
    default: {
      name: "Otterscan",
      url: "https://explorer.zq2-protomainnet.zilliqa.com",
    },
  },
})

export const CHAIN_ZQ2_DOCKERCOMPOSE = defineChain({
  id: 87362,
  name: "Zq2 Dockercompose",
  nativeCurrency: { name: "ZIL", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:4201"],
    },
  },
  blockExplorers: {
    default: {
      name: "Otterscan",
      url: "http://localhost:5100/",
    },
  },
})

export const MOCK_CHAIN = defineChain({
  id: 9999999,
  name: "Mock Chain",
  nativeCurrency: { name: "ZIL", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["NOT_USED"],
    },
  },
  blockExplorers: {
    default: {
      name: "NOT_USED",
      url: "NOT_USED",
    },
  },
})

function getConnectorsForWallets(walletConnectApiKey: string, appUrl: string) {
  return connectorsForWallets(
    [
      {
        groupName: "Recommended",
        wallets: [
          metaMaskWallet,
          walletConnectWallet,
          coinbaseWallet,
          rabbyWallet,
          trustWallet,
          ledgerWallet,
          rainbowWallet,
          phantomWallet,
        ],
      },
    ],
    {
      appName: "ZQ2 Staking",
      projectId: walletConnectApiKey,
      appUrl,
    }
  )
}

export function getChain(chainId: number) {
  const chain = [
    CHAIN_ZQ2_DEVNET,
    CHAIN_ZQ2_PROTOTESTNET,
    CHAIN_ZQ2_PROTOMAINNET,
    CHAIN_ZQ2_DOCKERCOMPOSE,
    MOCK_CHAIN,
  ].find((chain) => chain.id === chainId)

  if (!chain) {
    throw new Error(`Active chain [${chainId}] is not defined`)
  }

  return chain
}

let wagmiConfig: ReturnType<typeof createConfig> | null = null

export function getWagmiConfig(
  chainId: number,
  walletConnectApiKey: string,
  appUrl: string
) {
  if (!wagmiConfig) {
    wagmiConfig = createConfig({
      chains: [getChain(chainId)],
      client({ chain }) {
        return createClient({ chain, transport: http() })
      },
      connectors: getConnectorsForWallets(walletConnectApiKey, appUrl),
      ssr: true,
    })
  }

  return wagmiConfig
}

export function getViemClient(chainId: number) {
  return createPublicClient({
    chain: getChain(chainId),
    transport: http(),
  })
}

```

`src/misc/formatting.ts`:

```ts
import { DateTime } from "luxon"
import { formatUnits } from "viem"
import { getChain } from "./chainConfig"

export function formatPercentage(value: number) {
  return `${parseFloat((value * 100).toFixed(2))}%`
}

export function formatAddress(address: string) {
  return `${address.slice(0, 5)}...${address.slice(-3)}`
}

export function getHumanFormDuration(availableAt: DateTime) {
  const units = availableAt
    .diff(DateTime.now())
    .shiftTo("days", "hours", "minutes")
    .toHuman({
      unitDisplay: "long",
      listStyle: "narrow",
      maximumFractionDigits: 0,
    })

  const mostSignificantUnit = units
    .split(",")
    .map((units) => units.trim())
    .reduce((acc, unit) => {
      if (acc !== "") {
        return acc
      }

      // check if unit starts with smh different that 0
      // e.g., 0 days 2 hours 5 minutes should return "2 hours"
      if (unit[0] !== "0") {
        return unit
      }

      return acc
    }, "")

  if (mostSignificantUnit === "") {
    return "< 1 minute"
  } else {
    return `~${mostSignificantUnit}`
  }
}

export function convertTokenToZil(
  tokenAmount: bigint,
  zilToTokenRate: number
): bigint {
  const rate = BigInt(Math.round((1 / zilToTokenRate) * 10000000))
  const amount = (tokenAmount * rate) / 10000000n
  return amount
}

export function convertZilValueToToken(
  zilAmount: number,
  zilToTokenRate: number
) {
  return `${(zilAmount * zilToTokenRate).toFixed(2)}`
}

/**
 * returns @param value formatted to a string that is using the most appropriate unit
 * e.g., 1,000,000 ZIL will be formatted as 1M ZIL
 *
 * @note this function is useful for displaying large values
 */
export function formatUnitsToHumanReadable(
  value: bigint,
  decimals: number
): string {
  const raw = parseFloat(formatUnits(value, decimals))

  const formatter = new Intl.NumberFormat("en-US", {
    notation: "compact",
    compactDisplay: "short",
  })

  return formatter.format(raw)
}

/**
 * returns @param value formatted to a string with a maximum precision of @param maxPrecision
 * trailing zeros are removed
 *
 * @note this function is useful for displaying small values
 */
export function formatUnitsWithMaxPrecision(
  value: bigint,
  decimals: number,
  maxPrecision: number
): string {
  const raw = parseFloat(formatUnits(value, decimals))

  const formatted = raw.toFixed(maxPrecision).replace(/\.?0+$/, "")
  return formatted
}

export function getTxExplorerUrl(txHash: string, chainId: number) {
  return `${getChain(chainId).blockExplorers.default.url}/tx/${txHash}`
}

```

`src/misc/stakingAbis.ts`:

```ts
export const depositAbi = [
  {
    inputs: [],
    name: "getFutureTotalStake",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "withdrawalPeriod",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
] as const

/**
 * from Delegation.sol
 */
export const baseDelegatorAbi = [
  {
    inputs: [],
    name: "stake",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "shares",
        type: "uint256",
      },
    ],
    name: "unstake",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "claim",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "getPendingClaims",
    outputs: [
      {
        internalType: "uint256[2][]",
        name: "claims",
        type: "uint256[2][]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getMinDelegation",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getCommission",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getStake",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getClaimable",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
] as const

/**
 * From ILiquidDelegation.sol
 */
const _liquidDelegatorAbi = [
  {
    inputs: [],
    name: "getLST",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
] as const

/**
 * From INonLiquidDelegation
 */
const _nonLiquidDelegatorAbi = [
  {
    inputs: [],
    name: "getDelegatedAmount",
    outputs: [
      {
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "rewards",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getDelegatedTotal",
    outputs: [
      {
        internalType: "uint256",
        name: "result",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "withdrawAllRewards",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "stakeRewards",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const

export const liquidDelegatorAbi = [
  ..._liquidDelegatorAbi,
  ...baseDelegatorAbi,
] as const
export const nonLiquidDelegatorAbi = [
  ..._nonLiquidDelegatorAbi,
  ...baseDelegatorAbi,
] as const

```

`src/misc/stakingPoolsConfig.ts`:

```ts
import {
  Address,
  ContractFunctionArgs,
  ContractFunctionName,
  erc20Abi,
  formatUnits,
  parseUnits,
  ReadContractReturnType,
} from "viem"
import {
  CHAIN_ZQ2_PROTOTESTNET,
  getViemClient,
  MOCK_CHAIN,
  CHAIN_ZQ2_DEVNET,
  CHAIN_ZQ2_PROTOMAINNET,
} from "./chainConfig"
import { readContract } from "viem/actions"
import {
  depositAbi,
  liquidDelegatorAbi,
  nonLiquidDelegatorAbi,
} from "./stakingAbis"

/**
 * Deposit address is always the same
 */
const DEPOSIT_ADDRESS = "0x00000000005a494c4445504f53495450524f5859" as Address

export enum StakingPoolType {
  LIQUID = "LIQUID",
  NORMAL = "NON_LIQUID",
}

export interface StakingPoolDefinition {
  id: string
  name: string
  poolType: StakingPoolType
  address: string
  tokenAddress: string
  tokenDecimals: number
  tokenSymbol: string
  iconUrl: string
  minimumStake: bigint
  withdrawPeriodInMinutes: number
}

export interface StakingPoolData {
  tvl: bigint
  apr: number
  commission: number
  votingPower: number
  zilToTokenRate: number
}

export interface StakingPool {
  definition: StakingPoolDefinition
  data: StakingPoolData | null
}

export interface StakingPoolConfig {
  definition: StakingPoolDefinition
  delegatorDataProvider: (
    definition: StakingPoolDefinition,
    chainId: number
  ) => Promise<StakingPoolData>
}

async function mockDelegatorDataProvider(
  mockData: StakingPoolData,
  loadingMiliseconds: number
): Promise<StakingPoolData> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(mockData)
    }, loadingMiliseconds)
  })
}

async function fetchLiquidDelegatorDataFromNetwork(
  definition: StakingPoolDefinition,
  chainId: number
): Promise<StakingPoolData> {
  const viemClient = getViemClient(chainId)

  const readDelegatorContract = async <
    functionName extends ContractFunctionName<
      typeof liquidDelegatorAbi,
      "pure" | "view"
    >,
    const args extends ContractFunctionArgs<
      typeof liquidDelegatorAbi,
      "pure" | "view",
      functionName
    >,
  >(
    fname: functionName
  ): Promise<
    ReadContractReturnType<typeof liquidDelegatorAbi, functionName, args>
  > => {
    return readContract(viemClient, {
      address: definition.address as Address,
      abi: liquidDelegatorAbi,
      functionName: fname,
    })
  }

  try {
    const [
      totalSupply,
      zilToTokenRateWei,
      delegatorStake,
      depositTotalStake,
      [commissionNumerator, commissionDenominator],
    ] = await Promise.all([
      readContract(viemClient, {
        address: definition.tokenAddress as Address,
        abi: erc20Abi,
        functionName: "totalSupply",
      }),
      readDelegatorContract("getPrice"),
      readDelegatorContract("getStake"),
      readContract(viemClient, {
        address: DEPOSIT_ADDRESS,
        abi: depositAbi,
        functionName: "getFutureTotalStake",
      }),
      readDelegatorContract("getCommission"),
    ])

    const zilToTokenRate = 1 / parseFloat(formatUnits(zilToTokenRateWei, 18))

    const bigintDivisionPrecision = 1000000n

    const commission =
      Number(
        (commissionNumerator * bigintDivisionPrecision) / commissionDenominator
      ) / Number(bigintDivisionPrecision)
    const votingPower =
      Number((delegatorStake * bigintDivisionPrecision) / depositTotalStake) /
      Number(bigintDivisionPrecision)
    const rewardsPerYearInZil = 51000 * 24 * 365

    const delegatorYearReward = votingPower * rewardsPerYearInZil
    const delegatorRewardForShare = delegatorYearReward * (1 - commission)
    const apr =
      delegatorRewardForShare / parseFloat(formatUnits(delegatorStake, 18))

    return {
      tvl: totalSupply,
      commission,
      zilToTokenRate,
      votingPower,
      apr: apr,
    }
  } catch (error) {
    console.error("Error fetching total supply:", error)
    throw error
  }
}

async function fetchNonLiquidDelegatorDataFromNetwork(
  definition: StakingPoolDefinition,
  chainId: number
): Promise<StakingPoolData> {
  const viemClient = getViemClient(chainId)

  const readDelegatorContract = async <
    functionName extends ContractFunctionName<
      typeof nonLiquidDelegatorAbi,
      "pure" | "view"
    >,
    const args extends ContractFunctionArgs<
      typeof nonLiquidDelegatorAbi,
      "pure" | "view",
      functionName
    >,
  >(
    fname: functionName
  ): Promise<
    ReadContractReturnType<typeof nonLiquidDelegatorAbi, functionName, args>
  > => {
    return readContract(viemClient, {
      address: definition.address as Address,
      abi: nonLiquidDelegatorAbi,
      functionName: fname,
    })
  }

  try {
    const [
      tvl,
      delegatorStake,
      depositTotalStake,
      [commissionNumerator, commissionDenominator],
    ] = await Promise.all([
      readDelegatorContract("getDelegatedTotal"),
      readDelegatorContract("getStake"),
      readContract(viemClient, {
        address: DEPOSIT_ADDRESS,
        abi: depositAbi,
        functionName: "getFutureTotalStake",
      }),
      readDelegatorContract("getCommission"),
    ])

    const bigintDivisionPrecision = 1000000n

    const commission =
      Number(
        (commissionNumerator * bigintDivisionPrecision) / commissionDenominator
      ) / Number(bigintDivisionPrecision)
    const votingPower =
      Number((delegatorStake * bigintDivisionPrecision) / depositTotalStake) /
      Number(bigintDivisionPrecision)
    const rewardsPerYearInZil = 51000 * 24 * 365

    const delegatorYearReward = votingPower * rewardsPerYearInZil
    const delegatorRewardForShare = delegatorYearReward * (1 - commission)
    const apr =
      delegatorRewardForShare / parseFloat(formatUnits(delegatorStake, 18))

    return {
      tvl,
      commission,
      zilToTokenRate: 1,
      votingPower,
      apr: apr,
    }
  } catch (error) {
    console.error("Error fetching total supply:", error)
    throw error
  }
}

const twoWeeksInMinutes = 60 * 24 * 14
const fiveMinutesInMinutes = 5

export const stakingPoolsConfigForChainId: Record<
  string,
  Array<StakingPoolConfig>
> = {
  [MOCK_CHAIN.id]: [
    {
      definition: {
        id: "pool1",
        name: "Avely",
        poolType: StakingPoolType.LIQUID,
        address: "0x1234567890234567890234567890234567890",
        tokenAddress: "0x1234567890234567890234567890234567233",
        tokenDecimals: 18,
        tokenSymbol: "avZIL",
        iconUrl: "/static/logo2.webp",
        minimumStake: parseUnits("100", 18),
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: mockDelegatorDataProvider.bind(
        null,
        {
          tvl: parseUnits("3621786", 18),
          apr: 0.135,
          commission: 0.1,
          votingPower: 0.3,
          zilToTokenRate: 0.156374848922222,
        },
        2000
      ),
    },
    {
      definition: {
        id: "pool2",
        name: "Plunderswap",
        poolType: StakingPoolType.LIQUID,
        address: "0x82245678902345678902345678918278372382",
        tokenAddress: "0x1234567890234567890234567890234567231",
        tokenDecimals: 18,
        tokenSymbol: "plZIL",
        iconUrl: "/static/logo1.webp",
        minimumStake: parseUnits("100", 18),
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: mockDelegatorDataProvider.bind(
        null,
        {
          tvl: parseUnits("0", 18),
          apr: 0.21,
          commission: 0.011,
          votingPower: 0.5,
          zilToTokenRate: 0.7723232322,
        },
        1000
      ),
    },
    {
      definition: {
        id: "pool3",
        name: "IgniteDao",
        poolType: StakingPoolType.LIQUID,
        address: "0x96525678902345678902345678918278372212",
        tokenAddress: "0x1234567890234567890234567890234567232",
        tokenDecimals: 18,
        tokenSymbol: "igZIL",
        iconUrl: "/static/logo3.webp",
        minimumStake: parseUnits("100", 18),
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: mockDelegatorDataProvider.bind(
        null,
        {
          tvl: parseUnits("98173829", 18),
          apr: 1.1,
          commission: 0.05,
          votingPower: 0.2,
          zilToTokenRate: 0.9392382873,
        },
        5000
      ),
    },
    {
      definition: {
        id: "pool4",
        name: "ADAMine",
        poolType: StakingPoolType.LIQUID,
        address: "0x965256789023456789023456789182783K92Uh",
        tokenAddress: "0x1234567890234567890234567890234567234",
        tokenDecimals: 18,
        tokenSymbol: "adaZIL",
        iconUrl: "/static/logo5.webp",
        minimumStake: parseUnits("100", 18),
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: mockDelegatorDataProvider.bind(
        null,
        {
          tvl: parseUnits("100", 18),
          apr: 0.13,
          commission: 0.01,
          votingPower: 0.01,
          zilToTokenRate: 1.5,
        },
        500
      ),
    },
    {
      definition: {
        id: "K23k2322",
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        tokenAddress: "0x0000000000000000000000000000000000000000",
        iconUrl: "/static/quantum.webp",
        name: "Quantum",
        poolType: StakingPoolType.NORMAL,
        tokenDecimals: 18,
        tokenSymbol: "ZIL",
        minimumStake: parseUnits("100", 18),
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: mockDelegatorDataProvider.bind(
        null,
        {
          tvl: parseUnits("100000", 18),
          apr: 0.13,
          commission: 0.01,
          votingPower: 0.05,
          zilToTokenRate: 0.111112323232313,
        },
        100
      ),
    },
  ],
  [CHAIN_ZQ2_PROTOTESTNET.id]: [
    {
      definition: {
        id: "MHg3QTI4",
        address: "0x7A28eda6899d816e574f7dFB62Cc8A84A4fF92a6",
        tokenAddress: "0x3fE49722fC4F9F119AB18fE0CF7D340A23C8388b",
        iconUrl: "/static/logo2.webp",
        name: "Validator 1",
        poolType: StakingPoolType.LIQUID,
        tokenDecimals: 18,
        tokenSymbol: "LST1",
        minimumStake: parseUnits("100", 18),
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHg2MmYz",
        address: "0x62f3FC68ba2Ff62b23E73c48010262aD64054032",
        tokenAddress: "0x7854BFB32CC7a377165Ee3B5C8103a80A07913B2",
        iconUrl: "/static/logo1.webp",
        name: "Validator 2",
        poolType: StakingPoolType.LIQUID,
        tokenDecimals: 18,
        tokenSymbol: "LST2",
        minimumStake: parseUnits("100", 18),
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchLiquidDelegatorDataFromNetwork,
    },
  ],
  [CHAIN_ZQ2_DEVNET.id]: [
    {
      definition: {
        id: "MHg3YTBi",
        address: "0x7a0b7e6d24ede78260c9ddbd98e828b0e11a8ea2",
        tokenAddress: "0x9e5c257D1c6dF74EaA54e58CdccaCb924669dc83",
        iconUrl: "/static/collective.webp",
        name: "Collective",
        poolType: StakingPoolType.LIQUID,
        tokenDecimals: 18,
        tokenSymbol: "xZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: fiveMinutesInMinutes,
      },
      delegatorDataProvider: fetchLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHg3ZTAy",
        address: "0x7e02c204daf4e1140a331d6dfad1eeb265d9544f",
        tokenAddress: "0xDbdb7f1f01c438f9951d780Ac9C42E9795Bb938f",
        iconUrl: "/static/quantum.webp",
        name: "Quantum",
        poolType: StakingPoolType.LIQUID,
        tokenDecimals: 18,
        tokenSymbol: "yZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: fiveMinutesInMinutes,
      },
      delegatorDataProvider: fetchLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHg1OTZh",
        address: "0x983fC5214be8fB08A205902ea73A2cA10811060c",
        tokenAddress: "0x0000000000000000000000000000000000000000",
        iconUrl: "/static/citadel.webp",
        name: "Citadel",
        poolType: StakingPoolType.NORMAL,
        tokenDecimals: 18,
        tokenSymbol: "ZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: fiveMinutesInMinutes,
      },
      delegatorDataProvider: fetchNonLiquidDelegatorDataFromNetwork,
    },
  ],
  [CHAIN_ZQ2_PROTOMAINNET.id]: [
    {
      definition: {
        id: "MHhBMDU3",
        address: "0xA0572935d53e14C73eBb3de58d319A9Fe51E1FC8",
        tokenAddress: "0x0000000000000000000000000000000000000000",
        iconUrl: "/static/logo_moonlet.webp",
        name: "Moonlet",
        poolType: StakingPoolType.NORMAL,
        tokenDecimals: 18,
        tokenSymbol: "ZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchNonLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHgyQWJl",
        address: "0x2Abed3a598CBDd8BB9089c09A9202FD80C55Df8c",
        tokenAddress: "0xD8B61fed51b9037A31C2Bf0a5dA4B717AF0C0F78",
        iconUrl: "/static/logo_AtomicWallet.webp",
        name: "AtomicWallet",
        poolType: StakingPoolType.LIQUID,
        tokenDecimals: 18,
        tokenSymbol: "SHARK",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHhCOWQ2",
        address: "0xB9d689c64b969ad9eDd1EDDb50be42E217567fd3",
        tokenAddress: "0x0000000000000000000000000000000000000000",
        iconUrl: "/static/logo_cex.webp",
        name: "CEX.IO",
        poolType: StakingPoolType.NORMAL,
        tokenDecimals: 18,
        tokenSymbol: "ZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchNonLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHhlMEMw",
        address: "0xe0C095DBE85a8ca75de4749B5AEe0D18100a3C39",
        tokenAddress: "0x7B213b5AEB896bC290F0cD8B8720eaF427098186",
        iconUrl: "/static/logo_Plunderswap.webp",
        name: "PlunderSwap",
        poolType: StakingPoolType.LIQUID,
        tokenDecimals: 18,
        tokenSymbol: "pZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHhDMDI0",
        address: "0xC0247d13323F1D06b6f24350Eea03c5e0Fbf65ed",
        tokenAddress: "0x2c51C97b22E73AfD33911397A20Aa5176e7Ab951",
        iconUrl: "/static/logo_Luganodes.webp",
        name: "Luganodes",
        poolType: StakingPoolType.LIQUID,
        tokenDecimals: 18,
        tokenSymbol: "LNZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHg4QTBk",
        address: "0x8A0dEd57ABd3bc50A600c94aCbEcEf62db5f4D32",
        tokenAddress: "0x0000000000000000000000000000000000000000",
        iconUrl: "/static/logo_Dteam.webp",
        name: "DTEAM",
        poolType: StakingPoolType.NORMAL,
        tokenDecimals: 18,
        tokenSymbol: "ZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchNonLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHgzYjFD",
        address: "0x3b1Cd55f995a9A8A634fc1A3cEB101e2baA636fc",
        tokenAddress: "0x0000000000000000000000000000000000000000",
        iconUrl: "/static/logo_shardpool.svg",
        name: "Shardpool",
        poolType: StakingPoolType.NORMAL,
        tokenDecimals: 18,
        tokenSymbol: "ZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchNonLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHg2NmEy",
        address: "0x66a2bb4AD6999966616B2ad209833260F8eA07C8",
        tokenAddress: "0xA1Adc08C12c684AdB28B963f251d6cB1C6a9c0c1",
        iconUrl: "/static/logo_encapsulate.webp",
        name: "Encapsulate",
        poolType: StakingPoolType.LIQUID,
        tokenDecimals: 18,
        tokenSymbol: "encapZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchLiquidDelegatorDataFromNetwork,
    },
    {
      definition: {
        id: "MHhlNTlE",
        address: "0xe59D98b887e6D40F52f7Cc8d5fb4CF0F9Ed7C98B",
        tokenAddress: "0xf564DF9BeB417FB50b38A58334CA7607B36D3BFb",
        iconUrl: "/static/logo_stzill.webp",
        name: "Amazing Pool - Avely and ZilPay",
        poolType: StakingPoolType.LIQUID,
        tokenDecimals: 18,
        tokenSymbol: "stZIL",
        minimumStake: 10000000000000000000n,
        withdrawPeriodInMinutes: twoWeeksInMinutes,
      },
      delegatorDataProvider: fetchLiquidDelegatorDataFromNetwork,
    },
  ],
}

```

`src/misc/walletsConfig.ts`:

```ts
import { DateTime } from "luxon"
import { getViemClient, MOCK_CHAIN } from "./chainConfig"
import {
  stakingPoolsConfigForChainId,
  StakingPoolType,
} from "./stakingPoolsConfig"
import { readContract } from "viem/actions"
import { Address, erc20Abi, parseUnits } from "viem"
import { baseDelegatorAbi, nonLiquidDelegatorAbi } from "./stakingAbis"

export interface UserStakingPoolData {
  address: string
  stakingTokenAmount: bigint
}

export interface UserNonLiquidStakingPoolRewardData {
  address: string
  zilRewardAmount: bigint
}

export interface UserUnstakingPoolData {
  address: string
  zilAmount: bigint
  availableAt: DateTime
}

export interface DummyWallet {
  name: string
  address: string
  stakingTokenAmount: Array<UserStakingPoolData>
  unstakingEntries: Array<UserUnstakingPoolData>
  nonLiquidRewards: Array<UserNonLiquidStakingPoolRewardData>
  currentZil: bigint
}

export const dummyWallets: Array<DummyWallet> = [
  {
    name: "Mocked wallet 1 - empty wallet",
    address: "0xCF671756a8238cBeB19BCB4D77FC9091E2fCe1A3",
    currentZil: 0n,
    stakingTokenAmount: [],
    unstakingEntries: [],
    nonLiquidRewards: [],
  },
  {
    name: "Mocked wallet 2 - 0 ZIL, but some unstakes",
    address: "0xCF671756a8238cBeB19BCB4D77FC9091E2fCeYYY",
    currentZil: 0n,
    stakingTokenAmount: [],
    unstakingEntries: [
      {
        address: "0x1234567890234567890234567890234567890",
        zilAmount: parseUnits("62712.323", 18),
        availableAt: DateTime.now().minus({ days: 1 }),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("1000", 18),
        availableAt: DateTime.now().plus({ days: 1 }),
      },
    ],
    nonLiquidRewards: [],
  },
  {
    name: "Mocked wallet 3 - only have ZIL",
    address: "0xf0a9953B539f9E7c4953279859F924d9212B2111",
    currentZil: 1000000000000000000n,
    stakingTokenAmount: [],
    unstakingEntries: [],
    nonLiquidRewards: [],
  },
  {
    name: "Mocked wallet 4 - some liquid stakes",
    address: "0xf0a9953B539f9E7c4953279859F924d9212B9383",
    currentZil: 1000000000000000000n,
    stakingTokenAmount: [
      {
        address: "0x1234567890234567890234567890234567890",
        stakingTokenAmount: parseUnits("1000.50", 18),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        stakingTokenAmount: parseUnits("60.50", 18),
      },
    ],
    unstakingEntries: [],
    nonLiquidRewards: [],
  },
  {
    name: "Mocked wallet 5 - some liquid stakes and unstakes",
    address: "0xf0a9953B539f9E7c4953279859F924d9212B21A9",
    currentZil: 1000000000000000000000n,
    stakingTokenAmount: [
      {
        address: "0x1234567890234567890234567890234567890",
        stakingTokenAmount: parseUnits("1000", 18),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        stakingTokenAmount: parseUnits("9991119", 18),
      },
    ],
    unstakingEntries: [
      {
        address: "0x1234567890234567890234567890234567890",
        zilAmount: parseUnits("9000", 18),
        availableAt: DateTime.now().minus({ days: 1 }),
      },
      {
        address: "0x82245678902345678902345678918278372382",
        zilAmount: parseUnits("1044", 18),
        availableAt: DateTime.now().minus({ days: 5 }),
      },
      {
        address: "0x82245678902345678902345678918278372382",
        zilAmount: parseUnits("1000000", 18),
        availableAt: DateTime.now().plus({ days: 1 }),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("500", 18),
        availableAt: DateTime.now().plus({ days: 5 }),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("10000", 18),
        availableAt: DateTime.now().plus({ days: 13 }),
      },
    ],
    nonLiquidRewards: [],
  },
  {
    name: "Mocked wallet 6 - stakes, unstakes, rewards on non-liquid",
    address: "0xee00953B539f9E7c4953279859F924d9212B2000",
    currentZil: parseUnits("822", 18),
    stakingTokenAmount: [
      {
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        stakingTokenAmount: parseUnits("150.2", 18),
      },
    ],
    unstakingEntries: [
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("89", 18),
        availableAt: DateTime.now().plus({ days: 5 }),
      },
      {
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        zilAmount: parseUnits("220.2", 18),
        availableAt: DateTime.now().minus({ days: 5 }),
      },
      {
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        zilAmount: parseUnits("440.2", 18),
        availableAt: DateTime.now().plus({ days: 5 }),
      },
    ],
    nonLiquidRewards: [
      {
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        zilRewardAmount: parseUnits("10.2", 18),
      },
    ],
  },
  {
    name: "Mocked wallet 7 - LOTS of unstakes",
    address: "0xf0a9953B539f9E7c4953279859F924d9212BBBBBB",
    currentZil: 0n,
    stakingTokenAmount: [
      {
        address: "0x96525678902345678902345678918278372212",
        stakingTokenAmount: parseUnits("123.522039320", 18),
      },
      {
        address: "0x82245678902345678902345678918278372382",
        stakingTokenAmount: parseUnits("99999", 18),
      },
    ],
    unstakingEntries: [
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("89", 18),
        availableAt: DateTime.now().minus({ days: 5 }),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("123", 18),
        availableAt: DateTime.now().minus({ days: 4 }),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("1992", 18),
        availableAt: DateTime.now().minus({ days: 3 }),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("2311", 18),
        availableAt: DateTime.now().minus({ days: 2 }),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("2311", 18),
        availableAt: DateTime.now().plus({ days: 5 }),
      },
      {
        address: "0x96525678902345678902345678918278372212",
        zilAmount: parseUnits("122", 18),
        availableAt: DateTime.now().plus({ days: 15 }),
      },
      {
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        zilAmount: parseUnits("220.2", 18),
        availableAt: DateTime.now().minus({ days: 5 }),
      },
      {
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        zilAmount: parseUnits("1111.2", 18),
        availableAt: DateTime.now().minus({ days: 3 }),
      },
      {
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        zilAmount: parseUnits("220.2", 18),
        availableAt: DateTime.now().plus({ days: 5 }),
      },
      {
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        zilAmount: parseUnits("440.2", 18),
        availableAt: DateTime.now().plus({ days: 5 }),
      },
      {
        address: "0x82245678902345678902345678918278372382",
        zilAmount: parseUnits("1000000", 18),
        availableAt: DateTime.now().plus({ days: 1 }),
      },
      {
        address: "0x82245678902345678902345678918278372382",
        zilAmount: parseUnits("1000000", 18),
        availableAt: DateTime.now().plus({ days: 5 }),
      },
      {
        address: "0x82245678902345678902345678918278372382",
        zilAmount: parseUnits("1000000", 18),
        availableAt: DateTime.now().plus({ days: 15 }),
      },
      {
        address: "0x82245678902345678902345678918278372382",
        zilAmount: parseUnits("1000000", 18),
        availableAt: DateTime.now().plus({ days: 10 }),
      },
      {
        address: "0x82245678902345678902345678918278372382",
        zilAmount: parseUnits("1000000", 18),
        availableAt: DateTime.now().minus({ days: 1 }),
      },
    ],
    nonLiquidRewards: [
      {
        address: "0xe863906941de820bde06701a0d804dd0b8575d67",
        zilRewardAmount: parseUnits("1000.2", 18),
      },
    ],
  },
]

export async function getWalletStakingData(
  wallet: string,
  chainId: number
): Promise<UserStakingPoolData[]> {
  if (chainId === MOCK_CHAIN.id) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(
          dummyWallets.find((dw) => dw.address === wallet)
            ?.stakingTokenAmount || []
        )
      }, 1000)
    })
  } else {
    const stakingData: UserStakingPoolData[] = await Promise.all(
      stakingPoolsConfigForChainId[chainId].map(async (pool) => {
        if (pool.definition.poolType === StakingPoolType.LIQUID) {
          return {
            address: pool.definition.address,
            stakingTokenAmount: await readContract(getViemClient(chainId), {
              address: pool.definition.tokenAddress as Address,
              abi: erc20Abi,
              functionName: "balanceOf",
              args: [wallet as Address],
            }),
          }
        } else if (pool.definition.poolType === StakingPoolType.NORMAL) {
          return {
            address: pool.definition.address,
            stakingTokenAmount: await readContract(getViemClient(chainId), {
              address: pool.definition.address as Address,
              abi: nonLiquidDelegatorAbi,
              functionName: "getDelegatedAmount",
              account: wallet as Address,
            }),
          }
        } else {
          console.error(`Unknown pool type ${pool.definition.poolType}`, pool)
          return {
            address: pool.definition.address,
            stakingTokenAmount: 0n,
          }
        }
      })
    )

    return stakingData
  }
}

export async function getWalletUnstakingData(
  wallet: string,
  chainId: number
): Promise<UserUnstakingPoolData[]> {
  if (chainId === MOCK_CHAIN.id) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(
          dummyWallets.find((dw) => dw.address === wallet)?.unstakingEntries ||
            []
        )
      }, 1000)
    })
  } else {
    const currentBlockNumber = await getViemClient(chainId).getBlockNumber()

    // get unstaking data from contracts
    const unstakingWalletData = await Promise.all(
      stakingPoolsConfigForChainId[chainId].map(async (pool) => {
        return {
          address: pool.definition.address,
          blockNumberAndAmount: await readContract(getViemClient(chainId), {
            address: pool.definition.address as Address,
            abi: baseDelegatorAbi,
            functionName: "getPendingClaims",
            account: wallet as Address,
          }),
          claimableNow: (await readContract(getViemClient(chainId), {
            address: pool.definition.address as Address,
            abi: baseDelegatorAbi,
            functionName: "getClaimable",
            account: wallet as Address,
          })) as bigint,
        }
      })
    )

    // convert contracts raw data into application data
    const result: UserUnstakingPoolData[] = unstakingWalletData
      .filter(
        (uwd) => uwd.blockNumberAndAmount.length > 0 || uwd.claimableNow > 0
      )
      .map((uwd) => {
        const claims: UserUnstakingPoolData[] = []

        if (uwd.claimableNow > 0) {
          claims.push({
            zilAmount: uwd.claimableNow,
            availableAt: DateTime.now().minus({ days: 1 }), // just to make sure it displays
            address: uwd.address,
          })
        }

        if (uwd.blockNumberAndAmount.length > 0) {
          claims.push(
            ...uwd.blockNumberAndAmount.map((bna) => {
              const blocksRemaining = Number(bna[0] - currentBlockNumber)

              const blocksRemainingInSeconds = blocksRemaining * 1 // seconds per block

              return {
                zilAmount: bna[1],
                availableAt: DateTime.now().plus({
                  seconds: blocksRemainingInSeconds,
                }),
                address: uwd.address,
              }
            })
          )
        }

        return claims
      })
      .flat()

    return result
  }
}

export async function getWalletNonLiquidStakingPoolRewardData(
  wallet: string,
  chainId: number
): Promise<UserNonLiquidStakingPoolRewardData[]> {
  if (chainId === MOCK_CHAIN.id) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(
          dummyWallets.find((dw) => dw.address === wallet)?.nonLiquidRewards ||
            []
        )
      }, 1000)
    })
  } else {
    const rewards: Array<UserNonLiquidStakingPoolRewardData> =
      await Promise.all(
        stakingPoolsConfigForChainId[chainId]
          .filter((pool) => pool.definition.poolType === StakingPoolType.NORMAL)
          .map(async (pool) => {
            return {
              address: pool.definition.address,
              zilRewardAmount: await readContract(getViemClient(chainId), {
                address: pool.definition.address as Address,
                abi: nonLiquidDelegatorAbi,
                functionName: "rewards",
                account: wallet as Address,
              }),
            }
          })
      )

    return rewards.filter((r) => r.zilRewardAmount > 0n)
  }
}

```

`src/pages/_app.tsx`:

```tsx
import "@/styles/globals.css"
import "tailwindcss/tailwind.css"
import "@rainbow-me/rainbowkit/styles.css"
import { StakingPoolsStorage } from "@/contexts/stakingPoolsStorage"
import type { AppProps } from "next/app"
import { WalletConnector } from "@/contexts/walletConnector"
import DummyWalletSelector from "@/components/dummyWalletSelector"
import { ConfigProvider } from "antd"
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { WagmiProvider } from "wagmi"
import { RainbowKitProvider } from "@rainbow-me/rainbowkit"
import { StakingOperations } from "@/contexts/stakingOperations"
import { getWagmiConfig } from "@/misc/chainConfig"
import { useEffect, useState } from "react"
import { AppConfig } from "./api/config"
import { AppConfigStorage } from "@/contexts/appConfigStorage"
import Head from "next/head"
import { GoogleTagManager } from "@next/third-parties/google"

const queryClient = new QueryClient()

export default function App({ Component, pageProps }: AppProps) {
  const [appConfig, setAppConfig] = useState<AppConfig | null>(null)

  const [loadingSplashVisible, setLoadingSplashVisible] =
    useState<boolean>(true)
  const [loadingPercentage, setLoadingPercentage] = useState<number>(0)
  const [pageLoadStartTime] = useState<number>(Date.now())
  const intervalRateMiliseconds = 16
  const minimalLoadingTime = 1500

  useEffect(function loadAppConfig() {
    const fetchConfig = async () => {
      try {
        const res = await fetch("/api/config")
        const data = await res.json()
        setAppConfig(data)
      } catch (error) {
        console.error("Error loading config:", error)
      }
    }

    fetchConfig()
  }, [])

  const [loadingInterval] = useState<NodeJS.Timeout>(
    setInterval(function updateLoadingProgressState() {
      let newProgressValue = Math.min(
        (Date.now() - pageLoadStartTime) / minimalLoadingTime,
        1
      )

      if (newProgressValue >= 1) {
        newProgressValue = 1
        clearInterval(loadingInterval)
      }

      setLoadingPercentage(Math.round(newProgressValue * 100))
    }, intervalRateMiliseconds)
  )

  const fadeOut = loadingPercentage >= 100 && appConfig
  useEffect(
    function fadeOutLoadingScreen() {
      if (fadeOut) {
        setTimeout(() => {
          setLoadingSplashVisible(false)
        }, 500)
      }
    },
    [fadeOut]
  )

  return (
    <div className="relative">
      <Head>
        <title>Zilliqa Staking</title>
        <link
          rel="icon"
          type="image/png"
          sizes="16x16"
          href="/favicon-16x16.ico"
        />
        <link
          rel="icon"
          type="image/png"
          sizes="32x32"
          href="/favicon-32x32.ico"
        />
      </Head>

      {loadingSplashVisible && (
        <div
          className={`absolute left-0 top-0 !z-[100] h-screen w-screen bg-black text-white transition-opacity duration-500 ${
            fadeOut ? "opacity-0" : "opacity-100"
          }`}
        >
          <div className=" text-end text-2xl lg:text-3xl font-extrabold sm:mr-10 sm:mt-9 sm:mb-2 mr-5 mt-5 mb-1">
            {Math.round(loadingPercentage / 10) * 10}%
          </div>

          <div className="w-full h-[2px] ">
            <div
              className="h-full bg-colorful-gradient"
              style={{
                width: `${loadingPercentage}%`,
              }}
            ></div>
          </div>
        </div>
      )}

      {appConfig && (
        <AppConfigStorage.Provider initialState={{ appConfig }}>
          <GoogleTagManager gtmId={appConfig.gtmId} />
          <ConfigProvider>
            <WagmiProvider
              config={getWagmiConfig(
                appConfig.chainId,
                appConfig.walletConnectPrivateKey,
                appConfig.appUrl
              )}
              reconnectOnMount={true}
            >
              <QueryClientProvider client={queryClient}>
                <RainbowKitProvider showRecentTransactions={true}>
                  <WalletConnector.Provider>
                    <StakingPoolsStorage.Provider>
                      <StakingOperations.Provider>
                        <Component {...pageProps} />
                        <DummyWalletSelector />
                      </StakingOperations.Provider>
                    </StakingPoolsStorage.Provider>
                  </WalletConnector.Provider>
                </RainbowKitProvider>
              </QueryClientProvider>
            </WagmiProvider>
          </ConfigProvider>
        </AppConfigStorage.Provider>
      )}
    </div>
  )
}

```

`src/pages/_document.tsx`:

```tsx
import { Html, Head, Main, NextScript } from "next/document"

export default function Document() {
  return (
    <Html lang="en">
      <Head>
        <link
          href="https://fonts.googleapis.com/css2?family=Montserrat:wght@100;200;300;400;500;600;700;800;900&display=swap"
          rel="stylesheet"
        />
      </Head>
      <body className="max-h-screen overflow-hidden bg-[url('/static/stake-background.webp')] bg-right bg-no-repeat bg-cover bg-origin-content">
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}

```

`src/pages/api/config.ts`:

```ts
import type { NextApiRequest, NextApiResponse } from "next"

export type AppConfig = {
  chainId: number
  walletConnectPrivateKey: string
  intercomKey: string
  appUrl: string
  gtmId: string
}

function getStringFromEnv(name: string): string {
  const value = process.env[name]

  if (!value) {
    throw new Error(`${name} is not defined`)
  }

  return value
}

function getNumberFromEnv(name: string): number {
  const value = getStringFromEnv(name)
  const number = parseInt(value)

  if (isNaN(number)) {
    throw new Error(`${name} is not a number`)
  }

  return number
}

const config: AppConfig = {
  chainId: getNumberFromEnv("ZQ2_STAKING_CHAIN_ID"),
  walletConnectPrivateKey: getStringFromEnv(
    "ZQ2_STAKING_WALLET_CONNECT_API_KEY"
  ),
  intercomKey: getStringFromEnv("ZQ2_STAKING_INTERCOM_KEY"),
  appUrl: getStringFromEnv("ZQ2_STAKING_APP_URL"),
  gtmId: getStringFromEnv("ZQ2_STAKING_GTM_ID"),
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<AppConfig>
) {
  res.status(200).json(config)
}

```

`src/pages/api/health.ts`:

```ts
import type { NextApiRequest, NextApiResponse } from "next"

type Response = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Response>
) {
  res.status(200).json({ name: "ok" })
}

```

`src/pages/index.tsx`:

```tsx
import LoginView from "@/components/loginView"
import StakingPoolDetailsView from "@/components/stakingPoolDetailsView"
import StakingPoolsList from "@/components/stakingPoolsList"
import WithdrawZilView from "@/components/withdrawZilView"
import { AppConfigStorage } from "@/contexts/appConfigStorage"
import { StakingOperations } from "@/contexts/stakingOperations"
import { StakingPoolsStorage } from "@/contexts/stakingPoolsStorage"
import { WalletConnector } from "@/contexts/walletConnector"
import Intercom from "@intercom/messenger-js-sdk"
import { Modal } from "antd"
import Image from "next/image"
import { useRouter } from "next/router"
import { useEffect, useState } from "react"
import ArrowBackAqua from "../assets/svgs/arrow-back-aqua.svg"
import CustomWalletConnect from "@/components/customWalletConnect"
import MobilePopup from "@/components/mobilePopup"
import ZilGiveaway from "@/components/zilGiveaway"
import { StakingPoolType } from "@/misc/stakingPoolsConfig"

const HomePage = () => {
  const [isVisible, setIsVisible] = useState(false)
  const [viewClaim, setViewClaim] = useState(false)

  useEffect(() => {
    setIsVisible(true)
  }, [])

  const { appConfig } = AppConfigStorage.useContainer()
  const router = useRouter()

  const { isWalletConnected, walletAddress } = WalletConnector.useContainer()

  const {
    dummyWalletPopupContent,
    isDummyWalletPopupOpen,
    setIsDummyWalletPopupOpen,
  } = StakingOperations.useContainer()

  const {
    stakingPoolForView,
    selectStakingPoolForView,
    availableForUnstaking,
    pendingUnstaking,
  } = StakingPoolsStorage.useContainer()

  const [mobileShowClaims, setMobileShowClaims] = useState<boolean>(false)

  useEffect(() => {
    if (walletAddress) {
      Intercom({
        app_id: appConfig.intercomKey,
        user_id: walletAddress,
      })
    }
  }, [walletAddress])

  useEffect(() => {
    if (router.query.claims) {
      selectStakingPoolForView(null)
      setMobileShowClaims(true)
    } else {
      setMobileShowClaims(false)
    }
  }, [router.query.claims])

  const mobileOverlayWrapper = (children: React.ReactNode) => (
    <div className="absolute lg:hidden top-0 left-0 z-25 h-full w-full lg:bg-black1/65 max-lg:pb-12 py-5 4k:p-6 border-t-[0.6px] border-[#4B4B4B] rounded-t-3xl">
      {children}
    </div>
  )

  const desktopColumnContent = (
    <div className="hidden lg:block h-full 4k:h-[70vh] max-4k:items-center overflow-hidden">
      {!isWalletConnected && !stakingPoolForView ? (
        <LoginView />
      ) : stakingPoolForView ? (
        <div className="bg-black1/[68%] 4k:rounded-2.5xl rounded-tl-2.5xl h-full">
          <StakingPoolDetailsView
            stakingPoolData={stakingPoolForView.stakingPool}
            userStakingPoolData={stakingPoolForView.userData.staked}
            userUnstakingPoolData={stakingPoolForView.userData.unstaked}
            viewClaim={viewClaim}
            reward={stakingPoolForView.userData.reward}
          />
        </div>
      ) : (
        <WithdrawZilView setViewClaim={setViewClaim} />
      )}
    </div>
  )

  const mobileOverlayContent =
    mobileShowClaims && !stakingPoolForView
      ? mobileOverlayWrapper(<WithdrawZilView setViewClaim={setViewClaim} />)
      : stakingPoolForView &&
        mobileOverlayWrapper(
          <StakingPoolDetailsView
            stakingPoolData={stakingPoolForView.stakingPool}
            userStakingPoolData={stakingPoolForView.userData.staked}
            userUnstakingPoolData={stakingPoolForView.userData.unstaked}
            reward={stakingPoolForView.userData.reward}
          />
        )

  const mobileBottomNavition = (
    <div className="fixed bottom-0 left-0 lg:hidden w-full mt-7t-1.5">
      <div className="flex justify-between items-center gap-1 mb-5 mt-2 mx-5 md:mx-7">
        {isWalletConnected ? (
          <>
            <div className="flex justify-between items-center w-full max-lg:mr-16">
              {mobileShowClaims || stakingPoolForView ? (
                <div className="max-lg:w-full lg:min-w-[320px] mx-auto">
                  <div
                    className="justify-start flex items-center bold12"
                    onClick={() => {
                      router.back()
                    }}
                  >
                    <Image
                      className="mr-2 xs:mr-3 transform transition-transform ease-out duration-500 group-hover:-translate-x-2"
                      src={ArrowBackAqua}
                      alt={"arrow icon"}
                      width={8}
                      height={4.5}
                    />
                    Back
                  </div>
                </div>
              ) : (
                <div></div>
              )}

              <div className="flex items-center gap-3">
                <div
                  className={`justify-start bold12 relative max-lg:w-full lg:min-w-[320px] mx-auto whitespace-nowrap
                        ${!mobileShowClaims || (mobileShowClaims && stakingPoolForView) ? "text-tealPrimary" : "text-gray1"}
                        `}
                  onClick={() => {
                    if (stakingPoolForView) {
                      return
                    }

                    router.push(
                      {
                        query: {},
                      },
                      undefined,
                      { shallow: true }
                    )
                  }}
                >
                  {stakingPoolForView
                    ? `${stakingPoolForView.stakingPool.definition.name}`
                    : "Validators"}

                  <span
                    className={`absolute left-1/2 -translate-x-1/2 top-full mt-1 w-1 h-1
                  ${!mobileShowClaims || (mobileShowClaims && stakingPoolForView) ? "bg-tealPrimary " : " bg-transparent"}
                     rounded-full`}
                  />
                </div>

                <div
                  className={`h-inherit
                      ${stakingPoolForView ? "w-1/2" : "w-full"}`}
                >
                  <div
                    className={
                      "justify-start flex items-center whitespace-nowrap "
                    }
                    onClick={() => {
                      router.push(
                        {
                          query: { claims: true },
                        },
                        undefined,
                        { shallow: true }
                      )
                    }}
                  >
                    <div
                      className={` relative
                    ${mobileShowClaims && !stakingPoolForView ? "text-tealPrimary" : "text-gray1"}
                   whitespace-nowrap bold12`}
                    >
                      Claims
                      {mobileShowClaims && !stakingPoolForView && (
                        <span className="absolute left-1/2 -translate-x-1/2 top-full mt-1 w-1 h-1 bg-tealPrimary rounded-full" />
                      )}
                    </div>
                    {availableForUnstaking.length + pendingUnstaking.length !=
                      0 && (
                      <div
                        className={`bg-red1 text-white rounded-full px-2 h-4 w-4
                      text-8 font-bold p-0.5 ml-1 mb-5 items-center flex justify-center
                     ${availableForUnstaking.length + pendingUnstaking.length != 0 && "text-white"}`}
                      >
                        {availableForUnstaking.length + pendingUnstaking.length}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            </div>
          </>
        ) : (
          <>
            {stakingPoolForView && (
              <div className="w-1/2">
                <div className="max-lg:w-full lg:min-w-[320px] mx-auto">
                  <div
                    className="justify-start flex items-center bold12"
                    onClick={() => {
                      router.back()
                    }}
                  >
                    <Image
                      className="mr-2 xs:mr-3 transform transition-transform ease-out duration-500 group-hover:-translate-x-2"
                      src={ArrowBackAqua}
                      alt={"arrow icon"}
                      width={8}
                      height={4.5}
                    />
                    Back
                  </div>
                </div>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  )

  const [isOpen, setIsOpen] = useState(true)

  interface LogoProps {
    selectedPoolType: StakingPoolType
    onClick?: () => void
  }

  const Logo: React.FC<LogoProps> = ({ selectedPoolType, onClick }) => {
    const [color, setFillColor] = useState("#00D0C6")
    useEffect(() => {
      setFillColor(() => {
        switch (selectedPoolType) {
          case StakingPoolType.NORMAL:
            return "#5B6FFF"
          case StakingPoolType.LIQUID:
            return "#00D0C6"
          default:
            return "#00D0C6"
        }
      })
    }, [selectedPoolType])

    return (
      <div className="flex items-center">
        {/* desktop logo */}
        <svg
          width="50"
          height="50"
          viewBox="0 0 162 55"
          className="min-w-32 min-h-12 cursor-pointer  max-lg:hidden"
          onClick={onClick}
        >
          <defs>
            <style>
              {`
              .st0 { fill: ${color}; }
              .st1 { fill: #d8d8d8; }
              .st2 { fill: #fff; }
              .st3 { fill: #afafaf; }
            `}
            </style>
          </defs>
          <path
            className="st0"
            d="M56,50.1c-.7,0-1.4,0-2-.3-.6-.2-1.2-.5-1.5-.8l.6-1.3c.4.3.8.5,1.4.7s1.1.3,1.7.3.9,0,1.2-.2.5-.2.6-.4c.1-.2.2-.4.2-.6s0-.5-.3-.7c-.2-.2-.5-.3-.8-.4-.3-.1-.7-.2-1.1-.3-.4,0-.8-.2-1.2-.3-.4-.1-.7-.3-1.1-.5-.3-.2-.6-.4-.8-.8-.2-.3-.3-.7-.3-1.2s.1-.9.4-1.4c.3-.4.7-.7,1.2-1,.5-.3,1.2-.4,2.1-.4s1.1,0,1.6.2c.5.1,1,.3,1.4.6l-.5,1.3c-.4-.2-.8-.4-1.3-.5-.4-.1-.8-.2-1.2-.2s-.8,0-1.1.2c-.3.1-.5.3-.6.4-.1.2-.2.4-.2.6s0,.5.3.7c.2.2.5.3.8.4.3,0,.7.2,1.1.3.4,0,.8.2,1.2.3.4.1.7.3,1.1.4.3.2.6.4.8.7.2.3.3.7.3,1.2s-.1.9-.4,1.4c-.3.4-.7.7-1.2,1-.5.2-1.2.4-2.1.4ZM63.4,50v-7.7h-3v-1.4h7.7v1.4h-3v7.7h-1.7ZM67.9,50l4.1-9.1h1.7l4.1,9.1h-1.8l-3.5-8.2h.7l-3.5,8.2h-1.7ZM69.8,47.9l.5-1.3h4.9l.5,1.3h-5.8ZM80.7,47.9v-2c0,0,4.7-5,4.7-5h1.9l-4,4.2-.9,1-1.7,1.7ZM79.2,50v-9.1h1.7v9.1h-1.7ZM85.5,50l-3.5-4.1,1.1-1.2,4.3,5.4h-2ZM88.9,50v-9.1h1.7v9.1h-1.7ZM93.3,50v-9.1h1.4l5.7,7h-.7v-7h1.7v9.1h-1.4l-5.7-7h.7v7h-1.7ZM108.3,50.1c-.7,0-1.4-.1-2-.3-.6-.2-1.1-.6-1.5-1-.4-.4-.8-.9-1-1.5-.2-.6-.4-1.2-.4-1.9s.1-1.3.4-1.9c.2-.6.6-1.1,1-1.5.5-.4,1-.7,1.6-1,.6-.2,1.3-.4,2-.4s1.5.1,2.1.4c.6.3,1.1.6,1.6,1.1l-1.1,1c-.4-.4-.7-.6-1.2-.8-.4-.2-.9-.3-1.4-.3s-.9,0-1.3.2c-.4.2-.8.4-1.1.7-.3.3-.5.6-.7,1-.2.4-.2.8-.2,1.3s0,.9.2,1.3c.2.4.4.7.7,1,.3.3.6.5,1,.7.4.2.8.2,1.3.2s.9,0,1.3-.2c.4-.1.8-.4,1.2-.7l1,1.3c-.5.4-1,.7-1.7.9-.6.2-1.3.3-1.9.3ZM110.3,48.8v-3.4h1.6v3.6l-1.6-.2Z"
          />
          <path
            className="st2"
            d="M28.3,26.1l-18.7,9.2,18.7,8.9v7.2L1,38.5v-7.1l19-9.3L1,13.1v-7.2l27.3,12.9v7.3Z"
          />
          <path className="st1" d="M1,5.9l7.2-2.9,27.3,12.9-7.2,2.9L1,5.9Z" />
          <path className="st3" d="M28.3,26.1l7.2-2.9v-7.3l-7.2,2.9v7.3Z" />
          <path
            className="st3"
            d="M28.3,44.2v-14.3l7.2-3.3v21.9l-7.2,2.9v-7.2Z"
          />
          <path
            className="st2"
            d="M55.8,27.8h10.8v3.2h-16.4l11.1-19.4h-9.3v-3.2h14.9l-11.1,19.4Z"
          />
          <path className="st2" d="M74,8.4v22.6h-3.4V8.4h3.4Z" />
          <path className="st2" d="M82.9,8.4v19.4h6.6v3.2h-10.1V8.4h3.4Z" />
          <path className="st2" d="M96.1,8.4v19.4h6.6v3.2h-10V8.4h3.4Z" />
          <path className="st2" d="M109.4,8.4v22.6h-3.4V8.4h3.4Z" />
          <path
            className="st2"
            d="M137.8,31.4h-4.3l-1.8-1.8c-1.9,1.2-4,1.9-6.3,1.8-2.9,0-5.8-1.1-8-3.1-2.5-2.1-3.9-5.3-3.8-8.5,0-3.2,1.2-6.3,3.6-8.5,4.4-4.3,11.3-4.4,15.9-.4,2.7,2.3,4.1,5.4,4.1,9.1s-1.1,5.5-3.2,7.8l3.7,3.7h0ZM128.4,22l3.3,3.3c1.4-1.5,2.2-3.5,2.2-5.6,0-2.3-.8-4.5-2.4-6.1-3.3-3.3-8.6-3.3-12,0-1.6,1.6-2.3,3.7-2.3,6.2,0,2.2.8,4.4,2.4,6,1.5,1.5,3.6,2.4,5.8,2.4,1.4,0,2.8-.3,4-1l-5.3-5.1h4.4,0Z"
          />
          <path
            className="st2"
            d="M154.9,25.5h-9.7l-2.5,5.5h-3.7l11.2-24,10.8,24h-3.7l-2.3-5.5h0ZM153.4,22.3l-3.3-7.7-3.5,7.7h6.8Z"
          />
        </svg>

        {/* mobile logo */}
        <svg
          viewBox="0 0 88 27"
          className="h-8 sm:h-10 w-auto cursor-pointer lg:hidden"
          onClick={onClick}
        >
          <defs>
            <style>
              {`
              .st0 { fill: ${color}; }
              .st1 { fill: #d8d8d8; }
              .st2 { fill: #fff; }
              .st3 { fill: #afafaf; }
            `}
            </style>
          </defs>
          <path
            className="st0 max-xxs:hidden"
            d="M34.7,18.1c-.6,0-1.1,0-1.6-.2-.5-.2-.9-.4-1.2-.6l.5-1c.3.2.6.4,1.1.6.4.2.9.2,1.3.2s.7,0,.9-.1c.2,0,.4-.2.5-.3.1-.1.2-.3.2-.5s0-.4-.2-.5c-.2-.1-.4-.2-.6-.3-.2,0-.5-.2-.8-.2-.3,0-.6-.1-.9-.2-.3,0-.6-.2-.8-.4-.2-.2-.4-.4-.6-.6-.2-.2-.2-.6-.2-.9s.1-.7.3-1.1c.2-.3.5-.6,1-.8.4-.2,1-.3,1.6-.3s.9,0,1.3.2c.4.1.8.3,1.1.5l-.4,1c-.3-.2-.7-.3-1-.4-.3,0-.7-.1-1-.1s-.7,0-.9.1c-.2,0-.4.2-.5.4-.1.1-.2.3-.2.5s0,.4.2.5c.2.1.4.2.6.3.3,0,.5.2.8.2.3,0,.6.1.9.2.3,0,.6.2.8.4.3.1.5.3.6.6.2.2.2.6.2.9s-.1.7-.3,1.1c-.2.3-.5.6-1,.8-.4.2-1,.3-1.6.3ZM40.5,18v-6.1h-2.4v-1.1h6.1v1.1h-2.4v6.1h-1.3ZM44.1,18l3.2-7.2h1.3l3.3,7.2h-1.4l-2.8-6.5h.5l-2.8,6.5h-1.4ZM45.6,16.3l.4-1.1h3.9l.4,1.1h-4.6ZM54.2,16.3v-1.6c0,0,3.7-3.9,3.7-3.9h1.5l-3.1,3.3-.7.8-1.3,1.4ZM53,18v-7.2h1.3v7.2h-1.3ZM58,18l-2.8-3.3.9-1,3.4,4.3h-1.6ZM60.7,18v-7.2h1.3v7.2h-1.3ZM64.2,18v-7.2h1.1l4.5,5.6h-.5v-5.6h1.3v7.2h-1.1l-4.5-5.6h.5v5.6h-1.3ZM76.1,18.1c-.6,0-1.1,0-1.6-.3-.5-.2-.9-.4-1.2-.8-.4-.3-.6-.7-.8-1.2-.2-.5-.3-.9-.3-1.5s0-1,.3-1.5c.2-.5.5-.8.8-1.2.4-.3.8-.6,1.2-.8.5-.2,1-.3,1.6-.3s1.2,0,1.6.3c.5.2.9.5,1.2.9l-.8.8c-.3-.3-.6-.5-.9-.6-.3-.1-.7-.2-1.1-.2s-.7,0-1.1.2c-.3.1-.6.3-.8.5-.2.2-.4.5-.5.8-.1.3-.2.6-.2,1s0,.7.2,1c.1.3.3.6.5.8.2.2.5.4.8.5.3.1.7.2,1.1.2s.7,0,1-.2c.3-.1.7-.3,1-.6l.8,1c-.4.3-.8.5-1.3.7-.5.2-1,.2-1.5.2ZM77.7,17v-2.7h1.3v2.9l-1.3-.2Z"
          />
          <path
            className="st2"
            d="M19.2,13.1l-9.8,4.8,9.8,4.6v3.7l-14.2-6.7v-3.7l9.9-4.9L5,6.3v-3.7l14.2,6.7v3.8Z"
          />
          <path className="st1" d="M5,2.5l3.8-1.5,14.2,6.7-3.8,1.5L5,2.5Z" />
          <path className="st3" d="M19.2,13.1l3.8-1.5v-3.8l-3.8,1.5v3.8Z" />
          <path
            className="st3"
            d="M19.2,22.5v-7.5l3.8-1.7v11.4l-3.8,1.5v-3.7Z"
          />
        </svg>
      </div>
    )
  }

  const [selectedPoolType, setSelectedPoolType] = useState(
    StakingPoolType.LIQUID
  )

  //change this to true to show the alert when having issues in the site
  const [showAlert] = useState(false)

  return (
    <>
      <div
        className={`h-screen w-screen relative transition-opacity duration-1000 overflow-hidden flex flex-col gap-3 lg:gap-[4vh] ${
          isVisible ? "opacity-100" : "opacity-0"
        }`}
      >
        {/* Header */}
        <div className="w-full flex flex-col items-center justify-center text-white border-b-[0.5px] border-gray3">
          <div className="flex max-w-screen-2xl w-full justify-between px-4 lg:px-8 xl:px-12 4k:px-16 4k:max-w-screen-4k items-center py-4 lg:py-5">
            <div className="flex items-center">
              <Logo
                selectedPoolType={selectedPoolType}
                onClick={() =>
                  router.push({ query: {} }, undefined, { shallow: true })
                }
              />
            </div>

            <div className="flex gap-2 sm:gap-2.5 items-center">
              {isWalletConnected && <ZilGiveaway />}
              <CustomWalletConnect notConnectedClassName="btn-primary-teal sm:px-10 w-full sm:max-w-fit">
                Connect wallet
              </CustomWalletConnect>
            </div>
          </div>
          {showAlert && (
            <div className="w-full bg-red1 px-4 text-center text-sm font-bold leading-[1.2] py-2">
              We’re experiencing issues with chain, platform might not be
              responsive.
            </div>
          )}
        </div>
        <div className="grow relative mx-auto overflow-y-hidden max-w-screen-4k w-full">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-10 4k:gap-14 h-full max-lg:pb-16">
            {/* Left column */}
            <div
              className={`lg:bg-white/[9%] py-4 xs:py-6 4k:py-10 max-4k:rounded-s-none rounded-tr-2.5xl ${mobileOverlayContent && "max-lg:hidden"} overflow-hidden h-full flex flex-col `}
            >
              <StakingPoolsList
                selectedPoolType={selectedPoolType}
                setSelectedPoolType={setSelectedPoolType}
                setViewClaim={setViewClaim}
              />
            </div>

            {desktopColumnContent}

            {mobileOverlayContent}

            <MobilePopup
              isOpen={isOpen}
              onClose={() => setIsOpen(false)}
              isWalletConnected={!!isWalletConnected}
            />

            {mobileBottomNavition}
          </div>
        </div>

        <Modal
          title="User Wallet Interaction"
          open={isDummyWalletPopupOpen}
          okButtonProps={{ className: "btn-primary-cyan" }}
          okText="Confirm tx"
          cancelText="Cancel"
          onOk={dummyWalletPopupContent?.onOk}
          onCancel={dummyWalletPopupContent?.onCancel}
        >
          <div>{dummyWalletPopupContent?.content}</div>
        </Modal>
      </div>
    </>
  )
}

export default HomePage

```

`src/script/fetchPoolStaticData.ts`:

```ts
import yargs from "yargs/yargs"
import { hideBin } from "yargs/helpers"
import { readContract } from "viem/actions"
import { liquidDelegatorAbi, nonLiquidDelegatorAbi } from "@/misc/stakingAbis"
import { Address, erc20Abi } from "viem"
import { getViemClient } from "@/misc/chainConfig"
import {
  StakingPoolDefinition,
  StakingPoolType,
} from "@/misc/stakingPoolsConfig"

interface Args {
  network_id: string
  contract_address: string
  icon_url: string
  name: string
  type: StakingPoolType
}

async function readLiquidDelegator(
  poolDefinitionId: string,
  poolName: string,
  poolIconPublicPath: string,
  chainid: number,
  contractAddress: Address
): Promise<StakingPoolDefinition> {
  const viemClient = getViemClient(chainid)

  const [tokenAddress] = await Promise.all([
    readContract(viemClient, {
      address: contractAddress,
      abi: liquidDelegatorAbi,
      functionName: "getLST",
    }),
  ])

  const [tokenDecimals, tokenSymbol, minimumStake] = await Promise.all([
    readContract(viemClient, {
      address: tokenAddress,
      abi: erc20Abi,
      functionName: "decimals",
    }),
    readContract(viemClient, {
      address: tokenAddress,
      abi: erc20Abi,
      functionName: "symbol",
    }),
    readContract(viemClient, {
      address: contractAddress,
      abi: liquidDelegatorAbi,
      functionName: "getMinDelegation",
    }),
  ])

  const twoWeeksInMinutes = 60 * 24 * 14

  return {
    id: poolDefinitionId,
    address: contractAddress,
    tokenAddress,
    iconUrl: poolIconPublicPath,
    name: poolName,
    poolType: StakingPoolType.LIQUID,
    tokenDecimals,
    tokenSymbol,
    minimumStake,
    withdrawPeriodInMinutes: twoWeeksInMinutes,
  }
}

async function readNonLiquidDelegator(
  poolDefinitionId: string,
  poolName: string,
  poolIconPublicPath: string,
  chainid: number,
  contractAddress: Address
): Promise<StakingPoolDefinition> {
  const viemClient = getViemClient(chainid)

  const [minimumStake] = await Promise.all([
    readContract(viemClient, {
      address: contractAddress,
      abi: nonLiquidDelegatorAbi,
      functionName: "getMinDelegation",
    }),
  ])

  const twoWeeksInMinutes = 60 * 24 * 14

  return {
    id: poolDefinitionId,
    address: contractAddress,
    tokenAddress: "0x0000000000000000000000000000000000000000",
    iconUrl: poolIconPublicPath,
    name: poolName,
    poolType: StakingPoolType.NORMAL,
    tokenDecimals: 18,
    tokenSymbol: "ZIL",
    minimumStake,
    withdrawPeriodInMinutes: twoWeeksInMinutes,
  }
}

const argv = yargs(hideBin(process.argv))
  .option("network_id", {
    type: "string",
    description:
      "The network id of the network to connect to. It must be defined in chainConfig.ts",
    demandOption: true,
  })
  .option("contract_address", {
    type: "string",
    description: "The contract address in hex format",
    demandOption: true,
  })
  .option("icon_url", {
    type: "string",
    description: "The icon url of the pool",
    demandOption: true,
  })
  .option("name", {
    type: "string",
    description: "The name of the pool",
    demandOption: true,
  })
  .option("type", {
    choices: Object.values(StakingPoolType),
    type: "string",
    description: "The type of the pool",
    demandOption: true,
  })
  .help()
  .alias("help", "h").argv as Args

;(async () => {
  console.log(`Network RPC URL: ${argv.network_id}`)
  console.log(`Contract Address: ${argv.contract_address}`)

  const chainid = parseInt(argv.network_id)
  const contractAddress = argv.contract_address as Address
  const id = Buffer.from(`${contractAddress}"_"${argv.network_id}`)
    .toString("base64")
    .slice(0, 8)

  console.log("Add following definition to stakingPoolsConfig.ts")
  if (argv.type === StakingPoolType.LIQUID) {
    console.log({
      definition: await readLiquidDelegator(
        id,
        argv.name,
        argv.icon_url,
        chainid,
        contractAddress
      ),
    })
  } else {
    console.log({
      definition: await readNonLiquidDelegator(
        id,
        argv.name,
        argv.icon_url,
        chainid,
        contractAddress
      ),
    })
  }
})()

```